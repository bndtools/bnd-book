version=pmwiki-2.1.18 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10.7; rv:8.0) Gecko/20100101 Firefox/8.0
author=
csum=
ctime=1287242564
host=90.37.27.71
name=Bnd.Versioning
rev=11
targets=Bnd.Macros
text=(:title 11 Versioning:)%0a%0a%0ahttp://www.aqute.biz/uploads/Code/bnd.png%0a%0a!11 Versioning%0a%0aRequires 1.15%0a%0aVersioning is probably the most painful part of developing real software. Where toys and prototypes can be developed ignoring evolution, real software requires a migration path to an unknown future.%0a%0aThe OSGi has defined a versioning policy that is described in the [[http://www.osgi.org/wiki/uploads/Links/SemanticVersioning.pdf|Semantic Versioning whitepaper]]. bnd fully supports this model and provides many shortcuts. The goal of bnd is remove any manual work from versioning bundles as well as packages.%0a%0aThe key concept to version in OSGi is the ''package''. Bundles are an ''aggregate'' and therefore must move as fast as the fastest moving exported packages they contain. For example, if a bundle contains two exported packages @@foo@@ and @@bar@@ and @@foo@@ is not changed but @@bar@@ has a major change, then the bundle version needs to also have a major change. This requires an unnecessary update for a bundle that only depended on @@foo@@. Aggregating dependencies increases the fan out of the transitive dependencies. The result is that systems can only evolve when everything is updated simultaneously. The result is that the system as a whole becomes brittle.%0a%0aIn contrast, versioning the packages and using Import-Package, bundles can be refactored and versioned independently. %0a%0a!!Best Practices%0a%0a* Version on packages, not on bundles%0a* Create a packageinfo file with "version 1.0" in each package directory and maintain it meticuously for each change to the package. Any change that breaks consumers, increment major. Changes that break providers (if any), increment minor. Other changes micro. bnd will then properly version this package when exported%0a* If you provide an API (as defined in te Semantic Versioning whitepaper) export the API package even if it is not in your project and put the @@provide:=true@@ directive on the package export, e.g. @@Export-Package: org.osgi.service.event; provide:=true@@.%0a* Every time when you release a bundle to the external world, bump the minor part of the bundle  version. For internal development releases, bump the micro part of the bundle version.%0a%0a!!Versions in OSGi%0aA version in OSGi has 4 parts:%0a%0a  major        1%0a  minor        1.1%0a  micro        1.1.1%0a  qualifier    1.1.1.qualifier%0a%0aTo survive versioning, one must have a ''version policy''. A version policy puts semantics on the version numbers. The ''recommended'' policy in OSGi is changing the part when there is:%0a%0a  major        a breaking change%0a  minor        a backward compatible changes%0a  micro        a bug fix (no API change)%0a  qualifier    a new build%0a%0aIn OSGi, the decision was taken to have a single export version. The import statement allows a version range to be set. For example:%0a%0a  Export-Package: com.acme.foo; version=1.0.2%0a  Import-Package: com.acme.bar; version="[1,2)"%0a%0aThe semantic versioning white paper introduces two terms that are orthogonal to the imports and exports as well as implementing or delegating:%0a%0a* Provide an API - Provide the functionality defined in an API%0a* Consume an API - Consume the functionality defined in an API%0a%0aProvide and consume is orthogonal to implementing an interface and delegating. For example, the Configuration Admin service has the @@ConfigurationAdmin@@ interface that is implemented by the Provider of an API but the @@ConfigurationListener@@ interface is implemented by the Consumer of the API.%0a%0aThe reason for the providers and consumer terms is that version policies are different. A change in an API almost always affects the provider but with careful API design it is often possible to make a change backward compatible for consumers.%0a%0a!!Versioning Packages%0aIf you have a package that is containing implementation code that is supposed to be directly used by the consumers then this is a ''library''.%0aA library package is not an API that can be implemented by other bundles, it is the implementation. Then the versioning of library packages is relatively straightforward: Any change that breaks a consumer of that package must increment the major version number. For example, if the popular ASM library would add a method to the @@MethodVisitor@@ class then it must increment the major version number of the @@org.objectweb.asm@@ package because all existing consumers of this library would then be broken.%0a%0aIf however a package contains an API that is provided and consumed by others the situation is more complex. In such a case, the provider should export the API package and the consumers should import it.%0a%0abnd explicitly allows the inclusion of packages that come from other projects. It is just good practice to include an API package in your bundle if you are the provider of that API. However, this means that maintaining the version of the package in the manifest is ''wrong'', it would have to be maintained in several places, which is very error prone.%0a%0aFor this reason, bnd provides a way to store the version of the package together with the package itself. One with annotations and one without when annotations are not possible.%0a%0aThe @Version annotation is placed on the package. Since Java 5 it is possible to create a package-info.java file that can be used to annotate packages:%0a%0a  package-info.java:%0a    @Version("1.2.0.${build}")%0a    package com.example;%0a%0a    import aQute.bnd.annotation.Version;%0a%0aA non-annotation based alternative is the @@packageinfo@@ file. When bnd scans the Java archives it will look in each package for this packageinfo file. The format of this file is very simple:%0a%0a  packageinfo:%0a    version 1.2.0.v${build}%0a%0aIn either case, the value for the version may contain macros.%0a%0aIf you now export the package (from any bundle that has the package on its class path), it will be properly versioned.%0a%0a  bnd.bnd:%0a    build = ${tstamp}%0a    Export-Package: com.example.*%0a%0aThe resulting manifest will look like:%0a%0a  Manifest:%0a    Export-Package: com.example; version=1.2.0.v201010101010%0a%0aIf you export a a package from another bundle, bnd will also look in the manifest of that other bundle for a version.%0a%0aUsing packageinfo (or the @Version annotation) is highly recommended.%0a%0a!!Import Version Policy%0aIf you import a package bnd will look at the exported version of that package. This version is not directly suitable for the import because it is usually too specific, it needs a policy to convert this export version to an import version.%0a%0aAn importer that provides the functionality of an API package is much closer tied to that package than a client. The whitepaper recommends binding to the major.minor part of the version for a provider. That is, any change in the minor part of the version breaks the compatibility. This makes sense, the provider of an API must implement the contract and is therefore not backward compatible for any change in the API. A consumer of the API only has to be bound to the major part because it is much more relaxed for the backward compatibility.%0a%0aFor example, a new method is added to an interface that is implemented by the provider of the API. Old clients have no visibility of this method because when they compiled it did not exist. However, the provider of the API must be modified to implement this method otherwise more modern clients would break.%0a%0aThis asymmetry creates the need for two version policies:%0a%0a  -provider-policy :    ${range;[==,=+)}%0a  -consumer-policy :    ${range;[==,+)}%0a%0aThe given values are the defaults. The value of the version policy will be used calculate the import based on the exported package. The [[Macros#range|${range}]] macro provides a convenient shortcut to do this using a version mask.%0a%0aFor example, a bundle that implements the OSGi Event Admin service can use the following bnd file:%0a%0a  bnd.bnd:%0a    Private-Package: com.example.impl.event%0a%0aThe resulting manifest would look like:%0a%0a  Manifest:%0a    Import-Package:  org.osgi.service.event; version="[1.1,2)", ...%0a    ...%0a%0aHow does bnd know if a bundle is a provider or a consumer of a specific package? Well, the default is the consumer policy but this can be overridden with the @@provide:=true@@ directive that works on the @@Import-Package@@ clauses as well as on the @@Export-Package@@ clauses. %0a%0aThe @@provide:@@ directive indicates to bnd that the given package contains API that is provided by this bundle. The (strongly) recommended way is to put the @@provide:=true@@ directive on the @@Export-Package@@ header, even if the package comes from another bundle. This way the bundle contains a copy of the package that is by default imported with the proper provider policy range.%0a%0aFor example, an implementation of the OSGi Event Admin specification could use the following bnd file:%0a%0a  bnd.bnd:%0a    Export-Package:  org.osgi.service.event; provide:=true%0a    Private-Package: com.example.impl.event%0a%0aThe resulting manifest would look like:%0a%0a  Manifest:%0a    Export-Package:  org.osgi.service.event; version=1.1%0a    Import-Package:  org.osgi.service.event; version="[1.1,1.2)", ...%0a    ...%0a%0aIf for some reason it is not desirable to export the API package in the implementation bundle, then the @@provide:@@ directive can also be applied on the @@Import-Package@@ header:%0a%0a  bnd.bnd%0a    Import-Package: org.osgi.service.event; provide:=true, *%0a    Private-Package: com.example.impl.event%0a%0aThe resulting manifest would look like:%0a%0a  Manifest:%0a    Import-Package:  org.osgi.service.event; version="[1.1,1.2)", ...%0a    ...%0a%0a!!Substitution%0aA key aspect of OSGi is that a package can be both imported and exported. The reason is that this feature allows a framework more leeway during resolving without creating multiple unconnected class spaces.%0a%0aAfter the bundle has been created and analyzed bnd will see if an exported package is eligible for import. An export is automatically imported when the following are true:%0a%0a* There exists at least one reference to the exported package from a private package%0a* The exported package has no references to any private packages%0a* The exported package does not have a @@-noimport:@@ directive.%0a%0aIf a package is imported it will use the version as defined by the version policy.%0a%0a!!Versioning Bundles%0aVersioning bundles usually requires bumping the version every time it is placed in a repository. When package versioning is used, the bundle version is only important for tracking an artifact.%0a
time=1321889768
title=11 Versioning
author:1321889768=
diff:1321889768:1297073080:=70,71d69%0a%3c     import aQute.bnd.annotation.Version;%0a%3c %0a
host:1321889768=90.37.27.71
author:1297073080=
diff:1297073080:1296121957:=23,24c23,24%0a%3c * Every time when you release a bundle to the external world, bump the minor part of the bundle  version. For internal development releases, bump the micro part of the bundle version.%0a%3c %0a---%0a> * Every time when you release a bundle to the external world, bump the minor part of the version. For internal development releases, bump the micro version.%0a> %0a
host:1297073080=90.37.22.28
author:1296121957=
diff:1296121957:1288194322:=14,17c14,15%0a%3c The key concept to version in OSGi is the ''package''. Bundles are an ''aggregate'' and therefore must move as fast as the fastest moving exported packages they contain. For example, if a bundle contains two exported packages @@foo@@ and @@bar@@ and @@foo@@ is not changed but @@bar@@ has a major change, then the bundle version needs to also have a major change. This requires an unnecessary update for a bundle that only depended on @@foo@@. Aggregating dependencies increases the fan out of the transitive dependencies. The result is that systems can only evolve when everything is updated simultaneously. The result is that the system as a whole becomes brittle.%0a%3c %0a%3c In contrast, versioning the packages and using Import-Package, bundles can be refactored and versioned independently. %0a%3c %0a---%0a> The key concept to version in OSGi is the package. Bundles are an aggregate and therefore have to move to fast, causing many compatibility problems during deployment. By using Import-Package, bundles can be refactored and versioned independently of the packages.%0a> %0a20d17%0a%3c * Version on packages, not on bundles%0a25,53d21%0a%3c !!Versions in OSGi%0a%3c A version in OSGi has 4 parts:%0a%3c %0a%3c   major        1%0a%3c   minor        1.1%0a%3c   micro        1.1.1%0a%3c   qualifier    1.1.1.qualifier%0a%3c %0a%3c To survive versioning, one must have a ''version policy''. A version policy puts semantics on the version numbers. The ''recommended'' policy in OSGi is changing the part when there is:%0a%3c %0a%3c   major        a breaking change%0a%3c   minor        a backward compatible changes%0a%3c   micro        a bug fix (no API change)%0a%3c   qualifier    a new build%0a%3c %0a%3c In OSGi, the decision was taken to have a single export version. The import statement allows a version range to be set. For example:%0a%3c %0a%3c   Export-Package: com.acme.foo; version=1.0.2%0a%3c   Import-Package: com.acme.bar; version="[1,2)"%0a%3c %0a%3c The semantic versioning white paper introduces two terms that are orthogonal to the imports and exports as well as implementing or delegating:%0a%3c %0a%3c * Provide an API - Provide the functionality defined in an API%0a%3c * Consume an API - Consume the functionality defined in an API%0a%3c %0a%3c Provide and consume is orthogonal to implementing an interface and delegating. For example, the Configuration Admin service has the @@ConfigurationAdmin@@ interface that is implemented by the Provider of an API but the @@ConfigurationListener@@ interface is implemented by the Consumer of the API.%0a%3c %0a%3c The reason for the providers and consumer terms is that version policies are different. A change in an API almost always affects the provider but with careful API design it is often possible to make a change backward compatible for consumers.%0a%3c %0a55c23%0a%3c If you have a package that is containing implementation code that is supposed to be directly used by the consumers then this is a ''library''.%0a---%0a> If you have a package that is containing implementation code that is supposed to be directly by the consumers then this is a ''library''.%0a58,61c26,29%0a%3c If however a package contains an API that is provided and consumed by others the situation is more complex. In such a case, the provider should export the API package and the consumers should import it.%0a%3c %0a%3c bnd explicitly allows the inclusion of packages that come from other projects. It is just good practice to include an API package in your bundle if you are the provider of that API. However, this means that maintaining the version of the package in the manifest is ''wrong'', it would have to be maintained in several places, which is very error prone.%0a%3c %0a---%0a> If however a package contains an API that is provided and consumer by others the situation is more complex. In such a case, the provider should export the API package and the consumers should import it.%0a> %0a> bnd explicitly allows the inclusion of packages that come from other projects. It is just good practice to include an API package in your bundle if you are the provider of that API. However, this means that maintaining the version of the package in the manifest is wrong, it would have to be maintained in several places, which is evil.%0a> %0a90,91c58,59%0a%3c Using packageinfo (or the @Version annotation) is highly recommended.%0a%3c %0a---%0a> Using packageinfo (or its annotation) is highly recommended.%0a> %0a95,96c63,64%0a%3c An importer that provides the functionality of an API package is much closer tied to that package than a client. The whitepaper recommends binding to the major.minor part of the version for a provider. That is, any change in the minor part of the version breaks the compatibility. This makes sense, the provider of an API must implement the contract and is therefore not backward compatible for any change in the API. A consumer of the API only has to be bound to the major part because it is much more relaxed for the backward compatibility.%0a%3c %0a---%0a> The semantic versioning whitepaper has the concept of an API provider and an API consumer. An importer that provides the functionality of an API package is much closer tied to that package than a client. The whitepaper recommends binding to the major.minor part of the version for a provider. That is, any change in the minor part of the version breaks the compatibility. This makes sense, the provider of an API must implement the contract and is therefore not backward compatible for any change in the API. A consumer of the API only has to be bound to the major part because it is much more relaxed for the backward compatibility.%0a> %0a158a127%0a> %0a
host:1296121957=82.174.105.216
author:1288194322=
diff:1288194322:1288194041:=1,3c1,3%0a%3c (:title 11 Versioning:)%0a%3c %0a%3c %0a---%0a> (:title 07 Versioning:)%0a> %0a> %0a6,7c6,7%0a%3c !11 Versioning%0a%3c %0a---%0a> !07 Versioning%0a> %0a
host:1288194322=90.41.125.248
author:1288194041=
diff:1288194041:1288178384:=1,3c1,3%0a%3c (:title 07 Versioning:)%0a%3c %0a%3c %0a---%0a> (:title 06 Versioning:)%0a> %0a> %0a6,7c6,7%0a%3c !07 Versioning%0a%3c %0a---%0a> !06 Versioning%0a> %0a
host:1288194041=90.41.125.248
author:1288178384=
diff:1288178384:1288173991:=18c18%0a%3c * Create a packageinfo file with "version 1.0" in each package directory and maintain it meticuously for each change to the package. Any change that breaks consumers, increment major. Changes that break providers (if any), increment minor. Other changes micro. bnd will then properly version this package when exported%0a---%0a> * Create a packageinfo file with "version 1.0" in each package directory and maintain it meticuously for each change to the package. bnd will then properly version this package when exported%0a23,29c23,24%0a%3c If you have a package that is containing implementation code that is supposed to be directly by the consumers then this is a ''library''.%0a%3c A library package is not an API that can be implemented by other bundles, it is the implementation. Then the versioning of library packages is relatively straightforward: Any change that breaks a consumer of that package must increment the major version number. For example, if the popular ASM library would add a method to the @@MethodVisitor@@ class then it must increment the major version number of the @@org.objectweb.asm@@ package because all existing consumers of this library would then be broken.%0a%3c %0a%3c If however a package contains an API that is provided and consumer by others the situation is more complex. In such a case, the provider should export the API package and the consumers should import it.%0a%3c %0a%3c bnd explicitly allows the inclusion of packages that come from other projects. It is just good practice to include an API package in your bundle if you are the provider of that API. However, this means that maintaining the version of the package in the manifest is wrong, it would have to be maintained in several places, which is evil.%0a%3c %0a---%0a> If there is one thing that is important to version than it is your package. Now bnd explicitly allows the inclusion of packages that come from other project. It is just good practice to include an API package in your bundle if you are the provider of that API. However, this means that maintaining the version of the package in the manifest is wrong, it would have to be maintained in several places, which is evil.%0a> %0a
host:1288178384=90.41.125.248
author:1288173991=
diff:1288173991:1287248670:=3d2%0a%3c %0a8,122c7,17%0a%3c Requires 1.15%0a%3c %0a%3c Versioning is probably the most painful part of developing real software. Where toys and prototypes can be developed ignoring evolution, real software requires a migration path to an unknown future.%0a%3c %0a%3c The OSGi has defined a versioning policy that is described in the [[http://www.osgi.org/wiki/uploads/Links/SemanticVersioning.pdf|Semantic Versioning whitepaper]]. bnd fully supports this model and provides many shortcuts. The goal of bnd is remove any manual work from versioning bundles as well as packages.%0a%3c %0a%3c The key concept to version in OSGi is the package. Bundles are an aggregate and therefore have to move to fast, causing many compatibility problems during deployment. By using Import-Package, bundles can be refactored and versioned independently of the packages.%0a%3c %0a%3c !!Best Practices%0a%3c %0a%3c * Create a packageinfo file with "version 1.0" in each package directory and maintain it meticuously for each change to the package. bnd will then properly version this package when exported%0a%3c * If you provide an API (as defined in te Semantic Versioning whitepaper) export the API package even if it is not in your project and put the @@provide:=true@@ directive on the package export, e.g. @@Export-Package: org.osgi.service.event; provide:=true@@.%0a%3c * Every time when you release a bundle to the external world, bump the minor part of the version. For internal development releases, bump the micro version.%0a%3c %0a%3c !!Versioning Packages%0a%3c If there is one thing that is important to version than it is your package. Now bnd explicitly allows the inclusion of packages that come from other project. It is just good practice to include an API package in your bundle if you are the provider of that API. However, this means that maintaining the version of the package in the manifest is wrong, it would have to be maintained in several places, which is evil.%0a%3c %0a%3c For this reason, bnd provides a way to store the version of the package together with the package itself. One with annotations and one without when annotations are not possible.%0a%3c %0a%3c The @Version annotation is placed on the package. Since Java 5 it is possible to create a package-info.java file that can be used to annotate packages:%0a%3c %0a%3c   package-info.java:%0a%3c     @Version("1.2.0.${build}")%0a%3c     package com.example;%0a%3c %0a%3c A non-annotation based alternative is the @@packageinfo@@ file. When bnd scans the Java archives it will look in each package for this packageinfo file. The format of this file is very simple:%0a%3c %0a%3c   packageinfo:%0a%3c     version 1.2.0.v${build}%0a%3c %0a%3c In either case, the value for the version may contain macros.%0a%3c %0a%3c If you now export the package (from any bundle that has the package on its class path), it will be properly versioned.%0a%3c %0a%3c   bnd.bnd:%0a%3c     build = ${tstamp}%0a%3c     Export-Package: com.example.*%0a%3c %0a%3c The resulting manifest will look like:%0a%3c %0a%3c   Manifest:%0a%3c     Export-Package: com.example; version=1.2.0.v201010101010%0a%3c %0a%3c If you export a a package from another bundle, bnd will also look in the manifest of that other bundle for a version.%0a%3c %0a%3c Using packageinfo (or its annotation) is highly recommended.%0a%3c %0a%3c !!Import Version Policy%0a%3c If you import a package bnd will look at the exported version of that package. This version is not directly suitable for the import because it is usually too specific, it needs a policy to convert this export version to an import version.%0a%3c %0a%3c The semantic versioning whitepaper has the concept of an API provider and an API consumer. An importer that provides the functionality of an API package is much closer tied to that package than a client. The whitepaper recommends binding to the major.minor part of the version for a provider. That is, any change in the minor part of the version breaks the compatibility. This makes sense, the provider of an API must implement the contract and is therefore not backward compatible for any change in the API. A consumer of the API only has to be bound to the major part because it is much more relaxed for the backward compatibility.%0a%3c %0a%3c For example, a new method is added to an interface that is implemented by the provider of the API. Old clients have no visibility of this method because when they compiled it did not exist. However, the provider of the API must be modified to implement this method otherwise more modern clients would break.%0a%3c %0a%3c This asymmetry creates the need for two version policies:%0a%3c %0a%3c   -provider-policy :    ${range;[==,=+)}%0a%3c   -consumer-policy :    ${range;[==,+)}%0a%3c %0a%3c The given values are the defaults. The value of the version policy will be used calculate the import based on the exported package. The [[Macros#range|${range}]] macro provides a convenient shortcut to do this using a version mask.%0a%3c %0a%3c For example, a bundle that implements the OSGi Event Admin service can use the following bnd file:%0a%3c %0a%3c   bnd.bnd:%0a%3c     Private-Package: com.example.impl.event%0a%3c %0a%3c The resulting manifest would look like:%0a%3c %0a%3c   Manifest:%0a%3c     Import-Package:  org.osgi.service.event; version="[1.1,2)", ...%0a%3c     ...%0a%3c %0a%3c How does bnd know if a bundle is a provider or a consumer of a specific package? Well, the default is the consumer policy but this can be overridden with the @@provide:=true@@ directive that works on the @@Import-Package@@ clauses as well as on the @@Export-Package@@ clauses. %0a%3c %0a%3c The @@provide:@@ directive indicates to bnd that the given package contains API that is provided by this bundle. The (strongly) recommended way is to put the @@provide:=true@@ directive on the @@Export-Package@@ header, even if the package comes from another bundle. This way the bundle contains a copy of the package that is by default imported with the proper provider policy range.%0a%3c %0a%3c For example, an implementation of the OSGi Event Admin specification could use the following bnd file:%0a%3c %0a%3c   bnd.bnd:%0a%3c     Export-Package:  org.osgi.service.event; provide:=true%0a%3c     Private-Package: com.example.impl.event%0a%3c %0a%3c The resulting manifest would look like:%0a%3c %0a%3c   Manifest:%0a%3c     Export-Package:  org.osgi.service.event; version=1.1%0a%3c     Import-Package:  org.osgi.service.event; version="[1.1,1.2)", ...%0a%3c     ...%0a%3c %0a%3c If for some reason it is not desirable to export the API package in the implementation bundle, then the @@provide:@@ directive can also be applied on the @@Import-Package@@ header:%0a%3c %0a%3c   bnd.bnd%0a%3c     Import-Package: org.osgi.service.event; provide:=true, *%0a%3c     Private-Package: com.example.impl.event%0a%3c %0a%3c The resulting manifest would look like:%0a%3c %0a%3c   Manifest:%0a%3c     Import-Package:  org.osgi.service.event; version="[1.1,1.2)", ...%0a%3c     ...%0a%3c %0a%3c !!Substitution%0a%3c A key aspect of OSGi is that a package can be both imported and exported. The reason is that this feature allows a framework more leeway during resolving without creating multiple unconnected class spaces.%0a%3c %0a%3c After the bundle has been created and analyzed bnd will see if an exported package is eligible for import. An export is automatically imported when the following are true:%0a%3c %0a%3c * There exists at least one reference to the exported package from a private package%0a%3c * The exported package has no references to any private packages%0a%3c * The exported package does not have a @@-noimport:@@ directive.%0a%3c %0a%3c If a package is imported it will use the version as defined by the version policy.%0a%3c %0a%3c !!Versioning Bundles%0a%3c Versioning bundles usually requires bumping the version every time it is placed in a repository. When package versioning is used, the bundle version is only important for tracking an artifact.%0a%3c %0a---%0a> !!Version Policy%0a> The version policy defines how an import is bound to a matched export when the import is not decorated with a version. Assuming that the exporter has a version, than it would be desirable to take that version, adapt it in a specific way to a range and use that as the import version. This is exactly what the @@-versionpolicy@@ allows. The value of this option is a string that will be used for the value of the import version. %0a> %0a> A hard coded string would not be very valuable, it is therefore possible to use the ${@} macro. This macro will contain the actual export version when the import version is calculated. This actual version can be processed by the @@${version}@@ macro to create a truncated or incremented version. This is best elucidated with some examples. In the following examples the export version is 1.2.3.q.%0a> %0a> ||!-versionpolicy                             ||!version||%0a> ||${@}                                        ||1.2.3.q||%0a> ||${version;==;${@}}                          ||1.2 (default)||%0a> ||[${version;==;${@}},${version;=+;${@}})      ||[1.2,1.3)||%0a> ||[${version;==;${@}},${version;+;${@}})       ||[1.2,2)||%0a> %0a
host:1288173991=90.41.125.248
author:1287248670=
diff:1287248670:1287246450:=2,7c2,4%0a%3c %0a%3c http://www.aqute.biz/uploads/Code/bnd.png%0a%3c %0a%3c !06 Versioning%0a%3c %0a%3c !!Version Policy%0a---%0a> !Versioning%0a> [[#versionpolicy]]%0a> !!!Version Policy%0a
host:1287248670=90.41.247.141
author:1287246450=
diff:1287246450:1287246440:=1c1%0a%3c (:title 06 Versioning:)%0a---%0a> (:title 06 Versioning%0a
host:1287246450=90.41.247.141
author:1287246440=
diff:1287246440:1287242564:=1,2c1,2%0a%3c (:title 06 Versioning%0a%3c !Versioning%0a---%0a> !!Strategic%0a> %0a
host:1287246440=90.41.247.141
author:1287242564=
diff:1287242564:1287242564:=1,14d0%0a%3c !!Strategic%0a%3c %0a%3c [[#versionpolicy]]%0a%3c !!!Version Policy%0a%3c The version policy defines how an import is bound to a matched export when the import is not decorated with a version. Assuming that the exporter has a version, than it would be desirable to take that version, adapt it in a specific way to a range and use that as the import version. This is exactly what the @@-versionpolicy@@ allows. The value of this option is a string that will be used for the value of the import version. %0a%3c %0a%3c A hard coded string would not be very valuable, it is therefore possible to use the ${@} macro. This macro will contain the actual export version when the import version is calculated. This actual version can be processed by the @@${version}@@ macro to create a truncated or incremented version. This is best elucidated with some examples. In the following examples the export version is 1.2.3.q.%0a%3c %0a%3c ||!-versionpolicy                             ||!version||%0a%3c ||${@}                                        ||1.2.3.q||%0a%3c ||${version;==;${@}}                          ||1.2 (default)||%0a%3c ||[${version;==;${@}},${version;=+;${@}})      ||[1.2,1.3)||%0a%3c ||[${version;==;${@}},${version;+;${@}})       ||[1.2,2)||%0a%3c %0a
host:1287242564=90.41.247.141
