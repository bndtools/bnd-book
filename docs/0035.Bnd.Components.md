version=pmwiki-2.1.18 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10.7; rv:9.0) Gecko/20100101 Firefox/9.0
author=
csum=
ctime=1287242498
host=90.41.115.20
name=Bnd.Components
rev=22
targets=Bnd.MetaType
text=(:title 10 Service Components:)%0a%0ahttp://www.aqute.biz/uploads/Code/bnd.png%0a%0a!10 Service Components%0a''Version 1.42''%0a%0aThe Service-Component header is compatible with the standard OSGi header syntax. Any element in the list that does not have attributes must have a resource in the JAR and is copied as is to the manifest. However, simple components can also be defined inline, and it is even possible to pickup annotations. %0a%0aThe syntax for these component definitions is:%0a%0a  component ::= %3cname> ( ';' parameter ) * %0a  parameter ::= provide | reference | multiple | optional%0a              | reference | properties | factory | servicefactory%0a              | immediate | enabled | implementation %0a              | activate | deactivate | modified | configuration-policy%0a              | version | designate%0a%0a  reference ::= %3cname> '=' %3cinterface-class> %0a                 ( '(' %3ctarget-filter> ')')? cardinality?%0a  cardinality ::= '?' | '*' | '+' | '~'%0a  provide  ::= 'provide:=' LIST %0a  multiple  ::= 'multiple:=' LIST %0a  optional  ::= 'optional:=' LIST %0a  dynamic   ::= 'dynamic:=' LIST%0a  designate  ::= ( 'designate' | 'designateFactory' ) CLASS%0a  factory   ::= 'factory:=' true | false%0a  servicefactory := 'servicefactory:=' true | false%0a  immediate ::= 'immediate:=' true | false%0a  enabled   ::= 'enabled:=' true | false%0a  configuration-policy ::= "configuration-policy:=' %0a       ( 'optional' | 'require' | 'ignore' )%0a  activate  ::= 'activate:=' METHOD%0a  modified  ::= 'modified:=' METHOD%0a  deactivate::= 'deactivate:=' METHOD%0a  implementation::= 'implementation:=' %3cimplementation-class>%0a  properties::= 'properties:=' key '=' value  [=\=]%0a                ( ',' key '=' value ) *%0a  key       ::= NAME (( '@' | ':' ) type )?%0a  value     ::= value ( '|' value )*%0a%0aIf the name of the component maps to a resource, or ends in XML, or there are attributes set, then that clause is copied to the output Service-Component header.%0a%0aIf the name can be expanded to one or more classes that have component annotations (they must be inside the JAR), then each of those classes is analyzed for its component annotations. These annotations are then merged with the attributes from the header, where the header attributes override annotations. The expansion uses the normal wildcard rules. For example, @@biz.aQute.components.*@@ will search for component annotated classes in the  @@biz.aQute.components@@ package or one of its descendants. The classes must be present in the JAR. If no classes with annotations can be found for the @@name@@ then it is assumed to be name or implementation class name without annotations.%0a%0aThe name of the component is also the implementation class (unless overridden by the implementation: directive). It is then followed with a number of references and directives. A reference defines a name that can be used with the @@locateService@@ method from the @@ComponentContext@@ class. If the name starts with a lower case character, it is assume to be a bean property. In that case the reference is augmented with a @@set%3cName>@@ and @@unset%3cName>@@ method according to the standard bean rules. Bnd will interpret the header, read the annotations if possible, and create the corresponding resources in the output jar under the name @@OSGI-INF/%3cid>.xml@@. %0a%0aAnnotations are only recognized on the component class, super classes are not inspected for the components.%0a%0aThe supported annotations in the @@aQute.bnd.annotations.component@@ package are:%0a%0a||!Component||%0aAnnotated the class, indicates this class is required to be a component. It has the following properties:%0a%0a||  provide||Class[]||Service interfaces, the default is all directly implemented interfaces||%0a||name     ||String||Name of the component||%0a||factory  ||Boolean||Factory component||%0a||servicefactory||Boolean||Service Factory||%0a||immediate||Boolean||Immediate activation||%0a||designate||CLASS||Designate a class as a [[MetaType]] interface used for configurations for unitary configurations, see [[#metatype]]. This changes the default of the configurationPolicy to @@require@@.||%0a||designateFactory||CLASS||Designate a class as a [[MetaType]] interface used for configurations for factory configurations, see [[#metatype]]. This changes the default of the configurationPolicy to @@require@@.||%0a||configurationPolicy||OPTIONAL, REQUIRE, IGNORE||Configuration Policy||%0a||enabled||Boolean||Enabled component||%0a||properties||String[]||Properties specified as an array of @@key=value@@. The property type can be specified in the key as @@name:Integer@@. The value can contain multiple values, the parts must then be separated by a vertical bar ('|') or a line feed (\n), for example @@properties = {"primes:Integer==1|2|3|5|7|11"@@}.|| %0a%0a||!Reference||%0aOn a method. Indicates this method is the activate method. It has the following attributes%0a%0a||name||String||Name of the reference. Default this is the name of the method without set on it.||%0a||service||Class||The service type, default is the argument type of the method. The unset method is derived from this name. I.e. setXX will have an unsetXX method to unset the reference.||%0a||type||Character||Standard cardinality type '?', '*', '+','~'||%0a||target||String||A filter expression applied to the properties of the target service||%0a||unbind||String||Optional name of the unbind method. By default this is the same name as the bind method name but with set/add replaced with unset/remove. E.g. setFoo() bind method becomes unsetFoo() unbind method.||%0a%0a%0a@@@Reference@@ automatically sets the bind method. The unbind method is set by using a derived name from the bind method or providing it with the name of the unbind method. The following name patterns are supported:%0a%0a||!bind||!unbind||%0a||@@setX@@ ||@@unsetX@@||%0a||@@addX@@ ||@@removeX@@||%0a||@@xxxX@@ ||@@unxxxX@@||%0aFor example:%0a  @Reference%0a  protected void setFoo(LogService l) { ... }%0a  protected void unsetFoo(LogService l) { ... }%0aIf you want to override this, use%0a  @Reference(unbind="IRefuseToCallMyMethodUnFoo");%0a  protected void foo(LogService l) {}%0a  protected void IRefuseToCallMyMethodUnFoo(LogService l) {}%0aUnfortunately Java has no method references so it is not type safe.A non existent @@@UnReference@@ annotation is not very useful because that still requires linking it up symbolically to the associated @@@Reference@@.%0a%0a||!Activate, Modified, and Deactivate||%0aThe life cycle methods. These annotations have no properties.%0a%0a  %0aAssume the JAR contains the following class:%0a%0a  package com.acme;%0a  import org.osgi.service.event.*;%0a  import org.osgi.service.log.*;%0a  import aQute.bnd.annotation.component.*;%0a%0a  @Component%0a  public class AnnotatedComponent implements EventHandler {%0a    LogService log;%0a%0a    @Reference%0a    void setLog(LogService log) { this.log=log; }%0a%0a    public void handleEvent(Event event) {%0a      log.log(LogService.LOG_INFO, event.getTopic());%0a    }%0a  }%0a%0aThe only thing necessary to register the Declarative Service component is to add the following Service-Component header:%0a%0a  Service-Component: com.acme.*%0a%0aThis header will look for annotations in all com.acme sub-packages for an annotated component. The resulting XML will look like:%0a%0a  OSGI-INF/com.acme.AnnotatedComponent.xml:%0a    %3c?xml version='1.0' encoding='utf-8'?>%0a      %3ccomponent name='com.acme.AnnotatedComponent'>%0a        %3cimplementation class='com.acme.AnnotatedComponent'/>%0a        %3cservice>%0a          %3cprovide interface='org.osgi.service.event.EventHandler'/>%0a        %3c/service>%0a        %3creference name='log'%0a          interface='org.osgi.service.log.LogService' %0a          bind='setLog'%0a          unbind='unsetLog'/>%0a      %3c/component>%0a%0aThe following example shows a component that is bound to the log service via the setLog method without annotations:  %0a%0a  Service-Component=aQute.tutorial.component.World; [=\=]%0a    log=org.osgi.service.log.LogService  %0a   %0aThe Service Component Runtime (SCR) offers a variety of options on the reference. Some options like the target can be used by adding the target filter after the interface name (this likely requires putting quotes around the interface name+filter). %0a%0aReferences can be suffixed with the following characters to indicate their cardinality:%0a%0a  Char          Cardinality    Policy%0a  ?             0..1           dynamic%0a  *             0..n           dynamic%0a  +             1..n           dynamic%0a  ~             0..1           static%0a                1              static%0a%0aFor a more complex example:%0a%0a  Service-Component=aQute.tutorial.component.World; [=\=]%0a    log=org.osgi.service.log.LogService?; [=\=]%0a    http=org.osgi.service.http.HttpService; [=\=]%0a    PROCESSORS="xierpa.service.processor.Processor(priority>1)+"; [=\=]%0a    properties:="wazaabi=true"%0a    %0aThe previous example will result in the following service component in the resource @@OSGI-INF/aQute.tutorial.component.World.xml@@:  %0a%0a  %3c?xml version="1.0" encoding="utf-8" ?>%0a   %3ccomponent name="aQute.tutorial.component.World">%0a     %3cimplementation class="aQute.tutorial.component.World" /> %0a     %3creference name="log" %0a       interface="org.osgi.service.log.LogService" %0a       cardinality="0..1" %0a       bind="setLog" %0a       unbind="unsetLog" %0a       policy="dynamic" /> %0a     %3creference name="http" %0a       interface="org.osgi.service.http.HttpService" %0a       bind="setHttp" %0a       unbind="unsetHttp" />%0a     %3creference name="PROCESSORS" %0a       interface="xierpa.service.processor.Processor" %0a       cardinality="1..n" %0a       policy="dynamic" %0a       target="(&(priority>=1)(link=false))" /> %0a   %3c/component> %0a%0aThe description also supports the immediate, enabled, factory, target, servicefactory, configuration-policy, activate, deactivate, and modified attributes. Refer to the Declarative Services definition for their semantics.%0a%0aIf any feature of the V1.1 namespace is used, then bnd will declare the namespace in the @@component@@ element. A specific namespace version can be set with the @@version@@ directive. This detection only works when components are used.%0a%0aBnd also supports setting the policy and cardinality through the following directives:%0a%0a  multiple:= LIST    names of references that have x..n%0a  optional:= LIST    names of references that have 0..x%0a  dynamic:=  LIST    names of references that are dynamic%0a%0a!!Components and Metatype%0aThe Service Component Runtime works closely together with the Configuration Admin to allow the components to be controlled through configuration. Configuration Admin knows two types of configuration:%0a%0a* Unitary%0a* Factory%0a%0aA unitary configuration can be set and changed but there is at most one of them. A Factory configuration can be used to create multiple instances of the same component. A component has a configuration policy that defines when no configuration is set.%0a%0a* optional - If no configuration is set (either unitary or factory) then the component is still created.%0a* require - This requires a unitary configuration to be set or one or more factory configurations before a component is created.%0a* ignore - Ignore configuration information%0a%0aA related standard is the Metatype standard. The Metatype Service provides a repository of property descriptors. Bundles can provide these descriptors in their bundles in the OSGI-INF/metatype directory. There are tools, like the [[http://felix.apache.org/site/apache-felix-web-console.html|Felix Webconsole]], that can provide an editing window for a configuration that is typed with a metatype description.%0a%0aIn practice, this is a powerful model that provides a lot of configurability for your components with easy editing but getting it all right is not trivial. To make this easier, bnd has made it ease to use configurations.%0a%0aIn this model, configurations are declared in an interface. For example, the following interface defines a simple message:%0a%0a  interface Config {%0a    String message(); // message to give%0a  }%0a%0aTo create a component that can work with this config, we need to designate that interface as the configuration interface for a component.%0a%0a  @Component(designate=Config.class)%0a  public class BasicComponent {%0a      Config config;%0a%0a      @Activate void activate(Map%3cString,Object> props) {%0a         config = Configurable.createConfig(props);%0a         System.out.println("Hi " + config.message());%0a      }%0a%0a      @Deactivate void deactivate() {%0a         System.out.println("Bye " + config.message());%0a      }%0a  }%0a%0aThis is an immediate component because it does not implement a service interface. It also requires a configuration because we have not specified this explicitly. When you use designate (or designateFactory) the default becomes require. This means that your component will only be created when there is actually configuration for it set.%0a%0aTo run this component, make sure you have the Felix Webconsole running and the MetaType service installed. In the Webconsole, you can click on%0a'''Configuration''', your component should be listed on this page. By Clicking on the component with the name '''Basic Component Config''' you get an editor window.%0a%0aThe editor is aware of the proper types, it uses the [[MetaType]] standard to describe the properties. bnd uses the type information on the interface as well as the optional Metadata annotations to create a rich description that allows the web console to provide a good editor.%0a%0aYou can fill in the message in the ''Message'' field. If you save the editor, your component prints the message with "Hi" in front of it. Deleting the configuration will print the message with "Bye".%0a%0aIf you change the message, you will see that the component is first deactivated and then reactivated again. This is the only possibility for the SCR because the component has not implemented a modified method. Adding the following method will change this, now changes to the configuration are signaled to the component and the component can continue to work. This is more complicated then recycling the component but it can create a more optimized system.%0a%0a  @Modified%0a  void modified( Map%3cString,Object> props) {%0a    // reuse activate method%0a    activate(props);%0a  }%0a%0aIt is also possible to take advantage of the configuration factories. In this model %0a%0aAn example, that implements a simple socket server on a configurable port and returns a message when a telnet session is opened to that port can be found on [[https://github.com/bnd/aQute/blob/master/aQute.metatype/src/aQute/metatype/components/ServerSocketComponent.java|Github]].%0a%0a
time=1323937165
title=10 Service Components
author:1323937165=
diff:1323937165:1323934688:=245,248c245,246%0a%3c It is also possible to take advantage of the configuration factories. In this model %0a%3c %0a%3c An example, that implements a simple socket server on a configurable port and returns a message when a telnet session is opened to that port can be found on [[https://github.com/bnd/aQute/blob/master/aQute.metatype/src/aQute/metatype/components/ServerSocketComponent.java|Github]].%0a%3c %0a---%0a> It is also possible to take advantage of the configuration factories. An example, that implements a simple socket server on a configurable port and returns a message when a telnet session is opened to that port can be found on https://github.com/bnd/aQute/blob/master/aQute.metatype/src/aQute/metatype/components/ServerSocketComponent.java%0a> %0a
host:1323937165=90.41.115.20
author:1323934688=
diff:1323934688:1304923856:=245,246c245,246%0a%3c It is also possible to take advantage of the configuration factories. An example, that implements a simple socket server on a configurable port and returns a message when a telnet session is opened to that port can be found on https://github.com/bnd/aQute/blob/master/aQute.metatype/src/aQute/metatype/components/ServerSocketComponent.java%0a%3c %0a---%0a> It is also possible to take advantage of the configuration factories. For example, the following code implements a little socket server on a configurable port and returns a message when a telnet session is opened to that port.%0a> %0a
host:1323934688=90.41.115.20
author:1304923856=
diff:1304923856:1304668235:=182,183c182,183%0a%3c If any feature of the V1.1 namespace is used, then bnd will declare the namespace in the @@component@@ element. A specific namespace version can be set with the @@version@@ directive. This detection only works when components are used.%0a%3c %0a---%0a> If any feature of the V1.1 namespace is used, then bnd will declare the namespace in the @@component@@ element. A specific namespace version can be set with the @@version@@ directive.%0a> %0a
host:1304923856=90.41.217.29
author:1304668235=
diff:1304668235:1300283065:=34,35c34,35%0a%3c   modified  ::= 'modified:=' METHOD%0a%3c   deactivate::= 'deactivate:=' METHOD%0a---%0a>   modified  ::= 'activate:=' METHOD%0a>   deactivate::= 'activate:=' METHOD%0a
host:1304668235=90.41.113.37
author:1300283065=
diff:1300283065:1300272978:=60,61d59%0a%3c ||designate||CLASS||Designate a class as a [[MetaType]] interface used for configurations for unitary configurations, see [[#metatype]]. This changes the default of the configurationPolicy to @@require@@.||%0a%3c ||designateFactory||CLASS||Designate a class as a [[MetaType]] interface used for configurations for factory configurations, see [[#metatype]]. This changes the default of the configurationPolicy to @@require@@.||%0a206,207c204,205%0a%3c In this model, configurations are declared in an interface. For example, the following interface defines a simple message:%0a%3c %0a---%0a> In this model, configurations are declared in an interface. For example, the following interface defines a simple unitary configuration for a server that sends a message on a port:%0a> %0a208a207%0a>     int port(); // server port%0a218c217,218%0a%3c       @Activate void activate(Map%3cString,Object> props) {%0a---%0a>       @Activate%0a>       void activate(Map%3cString,Object> props) {%0a223c223,224%0a%3c       @Deactivate void deactivate() {%0a---%0a>       @Deactivate%0a>       void deactivate() {%0a227,246d227%0a%3c %0a%3c This is an immediate component because it does not implement a service interface. It also requires a configuration because we have not specified this explicitly. When you use designate (or designateFactory) the default becomes require. This means that your component will only be created when there is actually configuration for it set.%0a%3c %0a%3c To run this component, make sure you have the Felix Webconsole running and the MetaType service installed. In the Webconsole, you can click on%0a%3c '''Configuration''', your component should be listed on this page. By Clicking on the component with the name '''Basic Component Config''' you get an editor window.%0a%3c %0a%3c The editor is aware of the proper types, it uses the [[MetaType]] standard to describe the properties. bnd uses the type information on the interface as well as the optional Metadata annotations to create a rich description that allows the web console to provide a good editor.%0a%3c %0a%3c You can fill in the message in the ''Message'' field. If you save the editor, your component prints the message with "Hi" in front of it. Deleting the configuration will print the message with "Bye".%0a%3c %0a%3c If you change the message, you will see that the component is first deactivated and then reactivated again. This is the only possibility for the SCR because the component has not implemented a modified method. Adding the following method will change this, now changes to the configuration are signaled to the component and the component can continue to work. This is more complicated then recycling the component but it can create a more optimized system.%0a%3c %0a%3c   @Modified%0a%3c   void modified( Map%3cString,Object> props) {%0a%3c     // reuse activate method%0a%3c     activate(props);%0a%3c   }%0a%3c %0a%3c It is also possible to take advantage of the configuration factories. For example, the following code implements a little socket server on a configurable port and returns a message when a telnet session is opened to that port.%0a%3c %0a
host:1300283065=90.42.72.131
author:1300272978=
diff:1300272978:1300272559:=188c188%0a%3c !!Components and Metatype%0a---%0a> !!Metatypes%0a202,227c202%0a%3c In practice, this is a powerful model that provides a lot of configurability for your components with easy editing but getting it all right is not trivial. To make this easier, bnd has made it ease to use configurations.%0a%3c %0a%3c In this model, configurations are declared in an interface. For example, the following interface defines a simple unitary configuration for a server that sends a message on a port:%0a%3c %0a%3c   interface Config {%0a%3c     int port(); // server port%0a%3c     String message(); // message to give%0a%3c   }%0a%3c %0a%3c To create a component that can work with this config, we need to designate that interface as the configuration interface for a component.%0a%3c %0a%3c   @Component(designate=Config.class)%0a%3c   public class BasicComponent {%0a%3c       Config config;%0a%3c %0a%3c       @Activate%0a%3c       void activate(Map%3cString,Object> props) {%0a%3c          config = Configurable.createConfig(props);%0a%3c          System.out.println("Hi " + config.message());%0a%3c       }%0a%3c %0a%3c       @Deactivate%0a%3c       void deactivate() {%0a%3c          System.out.println("Bye " + config.message());%0a%3c       }%0a%3c   }%0a---%0a> In practice, this is a powerful model that provides a lot of configurability for your components with easy editing but getting it all right is not trivial. To make this easier, bnd has integrated%0a\ No newline at end of file%0a
host:1300272978=90.42.72.131
author:1300272559=
diff:1300272559:1300271763:=17,18c17%0a%3c               | version | designate%0a%3c %0a---%0a>               | version%0a26d24%0a%3c   designate  ::= ( 'designate' | 'designateFactory' ) CLASS%0a187,202d184%0a%3c %0a%3c !!Metatypes%0a%3c The Service Component Runtime works closely together with the Configuration Admin to allow the components to be controlled through configuration. Configuration Admin knows two types of configuration:%0a%3c %0a%3c * Unitary%0a%3c * Factory%0a%3c %0a%3c A unitary configuration can be set and changed but there is at most one of them. A Factory configuration can be used to create multiple instances of the same component. A component has a configuration policy that defines when no configuration is set.%0a%3c %0a%3c * optional - If no configuration is set (either unitary or factory) then the component is still created.%0a%3c * require - This requires a unitary configuration to be set or one or more factory configurations before a component is created.%0a%3c * ignore - Ignore configuration information%0a%3c %0a%3c A related standard is the Metatype standard. The Metatype Service provides a repository of property descriptors. Bundles can provide these descriptors in their bundles in the OSGI-INF/metatype directory. There are tools, like the [[http://felix.apache.org/site/apache-felix-web-console.html|Felix Webconsole]], that can provide an editing window for a configuration that is typed with a metatype description.%0a%3c %0a%3c In practice, this is a powerful model that provides a lot of configurability for your components with easy editing but getting it all right is not trivial. To make this easier, bnd has integrated %0a\ No newline at end of file%0a
host:1300272559=90.42.72.131
author:1300271763=
diff:1300271763:1298467230:=6,7c6%0a%3c ''Version 1.42''%0a%3c %0a---%0a> %0a
host:1300271763=90.42.72.131
author:1298467230=
diff:1298467230:1294939725:=45,46d44%0a%3c Annotations are only recognized on the component class, super classes are not inspected for the components.%0a%3c %0a
host:1298467230=90.37.148.75
author:1294939725=
diff:1294939725:1294939397:=57,58c57%0a%3c ||properties||String[]||Properties specified as an array of @@key=value@@. The property type can be specified in the key as @@name:Integer@@. The value can contain multiple values, the parts must then be separated by a vertical bar ('|') or a line feed (\n), for example @@properties = {"primes:Integer==1|2|3|5|7|11"@@}.|| %0a%3c %0a---%0a> %0a
host:1294939725=90.37.28.58
author:1294939397=
diff:1294939397:1289483904:=36,38c36%0a%3c   key       ::= NAME (( '@' | ':' ) type )?%0a%3c   value     ::= value ( '|' value )*%0a%3c %0a---%0a> %0a
host:1294939397=90.37.28.58
author:1289483904=
diff:1289483904:1289483096:=65,81d64%0a%3c %0a%3c @@@Reference@@ automatically sets the bind method. The unbind method is set by using a derived name from the bind method or providing it with the name of the unbind method. The following name patterns are supported:%0a%3c %0a%3c ||!bind||!unbind||%0a%3c ||@@setX@@ ||@@unsetX@@||%0a%3c ||@@addX@@ ||@@removeX@@||%0a%3c ||@@xxxX@@ ||@@unxxxX@@||%0a%3c For example:%0a%3c   @Reference%0a%3c   protected void setFoo(LogService l) { ... }%0a%3c   protected void unsetFoo(LogService l) { ... }%0a%3c If you want to override this, use%0a%3c   @Reference(unbind="IRefuseToCallMyMethodUnFoo");%0a%3c   protected void foo(LogService l) {}%0a%3c   protected void IRefuseToCallMyMethodUnFoo(LogService l) {}%0a%3c Unfortunately Java has no method references so it is not type safe.A non existent @@@UnReference@@ annotation is not very useful because that still requires linking it up symbolically to the associated @@@Reference@@.%0a%3c %0a
host:1289483904=90.41.84.94
author:1289483096=
diff:1289483096:1288194306:=63,64c63%0a%3c ||unbind||String||Optional name of the unbind method. By default this is the same name as the bind method name but with set/add replaced with unset/remove. E.g. setFoo() bind method becomes unsetFoo() unbind method.||%0a%3c %0a---%0a> %0a
host:1289483096=90.41.84.94
author:1288194306=
diff:1288194306:1288194024:=1,2c1,2%0a%3c (:title 10 Service Components:)%0a%3c %0a---%0a> (:title 06 Service Components:)%0a> %0a5,6c5,6%0a%3c !10 Service Components%0a%3c %0a---%0a> !06 Service Components%0a> %0a
host:1288194306=90.41.125.248
author:1288194024=
diff:1288194024:1288007774:=1,2c1,2%0a%3c (:title 06 Service Components:)%0a%3c %0a---%0a> (:title 05 Service Components:)%0a> %0a5,6c5,6%0a%3c !06 Service Components%0a%3c %0a---%0a> !05 Service Components%0a> %0a
host:1288194024=90.41.125.248
author:1288007774=
diff:1288007774:1288007686:=68,69c68,69%0a%3c Assume the JAR contains the following class:%0a%3c %0a---%0a> Assume the JAR contains the following class"%0a> %0a
host:1288007774=90.41.125.248
author:1288007686=
diff:1288007686:1288007666:=28,29c28%0a%3c   configuration-policy ::= "configuration-policy:=' %0a%3c        ( 'optional' | 'require' | 'ignore' )%0a---%0a>   configuration-policy ::= "configuration-policy:=' ( 'optional' | 'require' | 'ignore' )%0a
host:1288007686=90.41.125.248
author:1288007666=
diff:1288007666:1288007619:=148c148%0a%3c        target="(&(priority>=1)(link=false))" /> %0a---%0a>        target="(priority>=1)" /> %0a
host:1288007666=90.41.125.248
author:1288007619=
diff:1288007619:1287248629:=61,62c61%0a%3c ||target||String||A filter expression applied to the properties of the target service||%0a%3c %0a---%0a> %0a148c147%0a%3c        target="(priority>=1)" /> %0a---%0a>        target="(priority>1)" /> %0a
host:1288007619=90.41.125.248
author:1287248629=
diff:1287248629:1287246400:=2,6c2,3%0a%3c %0a%3c http://www.aqute.biz/uploads/Code/bnd.png%0a%3c %0a%3c !05 Service Components%0a%3c %0a---%0a> !Service Components%0a> %0a
host:1287248629=90.41.247.141
author:1287246400=
diff:1287246400:1287242498:=1,3c1%0a%3c (:title 05 Service Components:)%0a%3c !Service Components%0a%3c %0a---%0a> !!!Service-Component Header%0a
host:1287246400=90.41.247.141
author:1287242498=
diff:1287242498:1287242498:=1,153d0%0a%3c !!!Service-Component Header%0a%3c The Service-Component header is compatible with the standard OSGi header syntax. Any element in the list that does not have attributes must have a resource in the JAR and is copied as is to the manifest. However, simple components can also be defined inline, and it is even possible to pickup annotations. %0a%3c %0a%3c The syntax for these component definitions is:%0a%3c %0a%3c   component ::= %3cname> ( ';' parameter ) * %0a%3c   parameter ::= provide | reference | multiple | optional%0a%3c               | reference | properties | factory | servicefactory%0a%3c               | immediate | enabled | implementation %0a%3c               | activate | deactivate | modified | configuration-policy%0a%3c               | version%0a%3c   reference ::= %3cname> '=' %3cinterface-class> %0a%3c                  ( '(' %3ctarget-filter> ')')? cardinality?%0a%3c   cardinality ::= '?' | '*' | '+' | '~'%0a%3c   provide  ::= 'provide:=' LIST %0a%3c   multiple  ::= 'multiple:=' LIST %0a%3c   optional  ::= 'optional:=' LIST %0a%3c   dynamic   ::= 'dynamic:=' LIST%0a%3c   factory   ::= 'factory:=' true | false%0a%3c   servicefactory := 'servicefactory:=' true | false%0a%3c   immediate ::= 'immediate:=' true | false%0a%3c   enabled   ::= 'enabled:=' true | false%0a%3c   configuration-policy ::= "configuration-policy:=' ( 'optional' | 'require' | 'ignore' )%0a%3c   activate  ::= 'activate:=' METHOD%0a%3c   modified  ::= 'activate:=' METHOD%0a%3c   deactivate::= 'activate:=' METHOD%0a%3c   implementation::= 'implementation:=' %3cimplementation-class>%0a%3c   properties::= 'properties:=' key '=' value  [=\=]%0a%3c                 ( ',' key '=' value ) *%0a%3c %0a%3c If the name of the component maps to a resource, or ends in XML, or there are attributes set, then that clause is copied to the output Service-Component header.%0a%3c %0a%3c If the name can be expanded to one or more classes that have component annotations (they must be inside the JAR), then each of those classes is analyzed for its component annotations. These annotations are then merged with the attributes from the header, where the header attributes override annotations. The expansion uses the normal wildcard rules. For example, @@biz.aQute.components.*@@ will search for component annotated classes in the  @@biz.aQute.components@@ package or one of its descendants. The classes must be present in the JAR. If no classes with annotations can be found for the @@name@@ then it is assumed to be name or implementation class name without annotations.%0a%3c %0a%3c The name of the component is also the implementation class (unless overridden by the implementation: directive). It is then followed with a number of references and directives. A reference defines a name that can be used with the @@locateService@@ method from the @@ComponentContext@@ class. If the name starts with a lower case character, it is assume to be a bean property. In that case the reference is augmented with a @@set%3cName>@@ and @@unset%3cName>@@ method according to the standard bean rules. Bnd will interpret the header, read the annotations if possible, and create the corresponding resources in the output jar under the name @@OSGI-INF/%3cid>.xml@@. %0a%3c %0a%3c The supported annotations in the @@aQute.bnd.annotations.component@@ package are:%0a%3c %0a%3c ||!Component||%0a%3c Annotated the class, indicates this class is required to be a component. It has the following properties:%0a%3c %0a%3c ||  provide||Class[]||Service interfaces, the default is all directly implemented interfaces||%0a%3c ||name     ||String||Name of the component||%0a%3c ||factory  ||Boolean||Factory component||%0a%3c ||servicefactory||Boolean||Service Factory||%0a%3c ||immediate||Boolean||Immediate activation||%0a%3c ||configurationPolicy||OPTIONAL, REQUIRE, IGNORE||Configuration Policy||%0a%3c ||enabled||Boolean||Enabled component||%0a%3c %0a%3c ||!Reference||%0a%3c On a method. Indicates this method is the activate method. It has the following attributes%0a%3c %0a%3c ||name||String||Name of the reference. Default this is the name of the method without set on it.||%0a%3c ||service||Class||The service type, default is the argument type of the method. The unset method is derived from this name. I.e. setXX will have an unsetXX method to unset the reference.||%0a%3c ||type||Character||Standard cardinality type '?', '*', '+','~'||%0a%3c %0a%3c ||!Activate, Modified, and Deactivate||%0a%3c The life cycle methods. These annotations have no properties.%0a%3c %0a%3c   %0a%3c Assume the JAR contains the following class"%0a%3c %0a%3c   package com.acme;%0a%3c   import org.osgi.service.event.*;%0a%3c   import org.osgi.service.log.*;%0a%3c   import aQute.bnd.annotation.component.*;%0a%3c %0a%3c   @Component%0a%3c   public class AnnotatedComponent implements EventHandler {%0a%3c     LogService log;%0a%3c %0a%3c     @Reference%0a%3c     void setLog(LogService log) { this.log=log; }%0a%3c %0a%3c     public void handleEvent(Event event) {%0a%3c       log.log(LogService.LOG_INFO, event.getTopic());%0a%3c     }%0a%3c   }%0a%3c %0a%3c The only thing necessary to register the Declarative Service component is to add the following Service-Component header:%0a%3c %0a%3c   Service-Component: com.acme.*%0a%3c %0a%3c This header will look for annotations in all com.acme sub-packages for an annotated component. The resulting XML will look like:%0a%3c %0a%3c   OSGI-INF/com.acme.AnnotatedComponent.xml:%0a%3c     %3c?xml version='1.0' encoding='utf-8'?>%0a%3c       %3ccomponent name='com.acme.AnnotatedComponent'>%0a%3c         %3cimplementation class='com.acme.AnnotatedComponent'/>%0a%3c         %3cservice>%0a%3c           %3cprovide interface='org.osgi.service.event.EventHandler'/>%0a%3c         %3c/service>%0a%3c         %3creference name='log'%0a%3c           interface='org.osgi.service.log.LogService' %0a%3c           bind='setLog'%0a%3c           unbind='unsetLog'/>%0a%3c       %3c/component>%0a%3c %0a%3c The following example shows a component that is bound to the log service via the setLog method without annotations:  %0a%3c %0a%3c   Service-Component=aQute.tutorial.component.World; [=\=]%0a%3c     log=org.osgi.service.log.LogService  %0a%3c    %0a%3c The Service Component Runtime (SCR) offers a variety of options on the reference. Some options like the target can be used by adding the target filter after the interface name (this likely requires putting quotes around the interface name+filter). %0a%3c %0a%3c References can be suffixed with the following characters to indicate their cardinality:%0a%3c %0a%3c   Char          Cardinality    Policy%0a%3c   ?             0..1           dynamic%0a%3c   *             0..n           dynamic%0a%3c   +             1..n           dynamic%0a%3c   ~             0..1           static%0a%3c                 1              static%0a%3c %0a%3c For a more complex example:%0a%3c %0a%3c   Service-Component=aQute.tutorial.component.World; [=\=]%0a%3c     log=org.osgi.service.log.LogService?; [=\=]%0a%3c     http=org.osgi.service.http.HttpService; [=\=]%0a%3c     PROCESSORS="xierpa.service.processor.Processor(priority>1)+"; [=\=]%0a%3c     properties:="wazaabi=true"%0a%3c     %0a%3c The previous example will result in the following service component in the resource @@OSGI-INF/aQute.tutorial.component.World.xml@@:  %0a%3c %0a%3c   %3c?xml version="1.0" encoding="utf-8" ?>%0a%3c    %3ccomponent name="aQute.tutorial.component.World">%0a%3c      %3cimplementation class="aQute.tutorial.component.World" /> %0a%3c      %3creference name="log" %0a%3c        interface="org.osgi.service.log.LogService" %0a%3c        cardinality="0..1" %0a%3c        bind="setLog" %0a%3c        unbind="unsetLog" %0a%3c        policy="dynamic" /> %0a%3c      %3creference name="http" %0a%3c        interface="org.osgi.service.http.HttpService" %0a%3c        bind="setHttp" %0a%3c        unbind="unsetHttp" />%0a%3c      %3creference name="PROCESSORS" %0a%3c        interface="xierpa.service.processor.Processor" %0a%3c        cardinality="1..n" %0a%3c        policy="dynamic" %0a%3c        target="(priority>1)" /> %0a%3c    %3c/component> %0a%3c %0a%3c The description also supports the immediate, enabled, factory, target, servicefactory, configuration-policy, activate, deactivate, and modified attributes. Refer to the Declarative Services definition for their semantics.%0a%3c %0a%3c If any feature of the V1.1 namespace is used, then bnd will declare the namespace in the @@component@@ element. A specific namespace version can be set with the @@version@@ directive.%0a%3c %0a%3c Bnd also supports setting the policy and cardinality through the following directives:%0a%3c %0a%3c   multiple:= LIST    names of references that have x..n%0a%3c   optional:= LIST    names of references that have 0..x%0a%3c   dynamic:=  LIST    names of references that are dynamic%0a
host:1287242498=90.41.247.141
