version=pmwiki-2.1.18 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:7.0) Gecko/20100101 Firefox/7.0
author=
csum=
ctime=1287242259
host=90.41.251.99
name=Bnd.Bnd
rev=16
targets=
text=(:title 01 Background:)%0a%0ahttp://www.aqute.biz/uploads/Code/bnd.png%0a%0a!01 Background%0abnd is the Swiss army knife of OSGi, it is used for creating and working with OSGi bundles. Its primary goal is take the pain out of developing bundles. With OSGi you are forced to provide additional metadata in the JAR's manifest to verify the consistency of your "class path". This metadata must be closely aligned with the class files in the bundle and the policies that a company has about versioning. Maintaining this metdata is an error prone chore because many aspects are redundant.%0a%0abnd's raison d'etre is therefore to remove the chores and use the redundancy to create the manifest from the class files instead of maintaining it by hand. The core task is therefore to analyze the class files and find any dependencies. These dependencies are then merged with ''instructions'' supplied by the user. For example, adding a version to all imported packages from a specific library can be specified as:%0a%0a  Import-Package: com.library.*; version = 1.21%0a%0aThe OSGi manifest must explicitly mention a package, bnd allows the use of wildcards. bnd contains many more such conveniences. bnd roots are about 10 years old and bnd has therefore a large number of functions that remove such chores. These range from simplifying the use of OSGi Declarative Services, working with Spring and Blueprint, WAR and WAB files, version analysis, project dependencies, and much more.%0a%0aOver time bnd started to appear in many different incarnations. It is an an ant task, a command line utility, and a bundle for Eclipse. Other projects have used bndlib to create a maven plugin, bndtools and Sigil both Eclipse IDEs, and others. By keeping the core library small and uncoupled (bnd has no external connections except Java 5), it is easy to embed the functionality in other projects.%0a%0a!!Workflow%0aTraditionally, JAR files were made with the JDK jar tool, the jar ant task, or the Maven packager. All these tools share the same concept. The developer creates a directory image of the jar by copying files to a directory; this directory is then jarred. This model can be called the ''push'' model. Obviously this method works well.%0a%0abnd works differently, it uses the ''pull'' model. Instructions in the bnd file describe the contents of the desired JAR file without writing this structure to disk. The contents from the output can come from the class path or from anywhere in the file system. For example, the following instruction includes the designated packages in the JAR:%0a%0a  Private-Package: com.example.*%0a %0abnd can create a JAR from packages the sources, directories or other JAR files. You never have to copy files around, the instructions that Bnd receives are sufficient to retrieve the files from their original location, preprocessing or filtering when required.%0a%0aThe Jar is constructed from 3 different arguments:%0a%0a  Export-Package%0a  Private-Package%0a  Include-Resource%0a%0aPrivate-Package and Export-Package contain ''instructions''. Instructions are patterns + attributes and directives, looking like normal OSGi attributes and directives. For example:%0a%0a  Export-Package: com.acme.*;version=1.2%0a%0aEach instruction is applied to each package on the classpath in the definition order. That is, if an earlier instruction matches, the later instruction never gets a chance to do its work. If an instruction matches its attributes and properties are applied to the packages. The difference between the Private-Package argument and the Export-Package arguments is that the export version selects the packages for export. If the packages overlap between the two, the export wins.%0a%0aAn instruction can also be negative when it starts with a '!'. In that case the package is excluded from the selection. For example:%0a%0a  Export-Package: !com.acme.impl, com.acme.*;version=1.2%0a%0aNote that the instructions are applied in order. If the ! instruction was at the end in the previous example, it would not have done its work because the com.acme.* would already have matched.%0a%0aThe Include-Resource argument can be used to copy resources from the file system in the JAR. This is useful for licenses, images, etc. The instructions in the argument can be a directory, a file, or an inline JAR. The default JAR path is the the root for a directory or the filename for a file. The path can be overridden. Instructions that are enclosed in curly braces, like {license.txt}, are pre-processed, expanding any macros in the file.%0a%0aOnce the JAR is created, the bnd program analyzes the classes and creates an import list with all the packages that are not contained in the jar but which are referred to. This import list is matched against the Import-Package instructions. Normally, the Import-Package argument is *; all referred packages will be imported. However, sometimes it is necessary to ignore an import or provide attributes on the import statement. For example, make the import optional or discard the import:%0a%0a  Import-Package: !com.acme.*, *;resolution:=optional%0a%0aThe arguments to bnd are normal given as a set of properties. Properties that begin with an upper case are copied to the manifest (possibly after processing). Lower case properties are used for macro variables but are not set as headers in the manifest.%0a%0aAfter the JAR is created, the bnd program will verify the result. This will check the resulting manifest in painstaking detail.%0a%0aThe bnd program works on a higher level then traditional jarring; this might take some getting used to. However, it is much more elegant to think in packages than that it is to think in files. The fact that bnd understand the semantics of a bundle allows it to detect many errors and allows bundles to be created with almost no special information. %0a%0abnd will not create an output file if none of the resources is newer than an existing output file.%0a%0aThe program is available in several forms: command line, ant task, maven plugin, and an Eclipse plugin.%0a%0a!!Tips%0aThere are some common pitfalls that can be prevented by following the tips:%0a* Keep it simple. bnd's defaults are pretty good and not specifying is usually the best solution. KISS!%0a* Think packages ... yes it feels redundant to specify the packages that are in your source directory but your artifact will get a life of its own over time. Many IDEs and build tools restricted us to one artifact per project but bnd allows many artifacts, allowing the choice of granularity to you. As OSGi's packages can be easily refactored you can design the contents of your artifacts depending on the deployment needs. Think packages!%0a* Private is always better than export, only use export when you absolute need it.%0a* Not versioning an exported package is at your own peril. Sorry, that is false, it is at the peril of your users.%0a* Do not use the Bundle-ClassPath, if you need to include whole JARs, see the @ option at Include-Resource%0a* If you do not understand a header, remove it%0a* If you have a problem, make an example that is as small as possible and send it to [[mailto:Peter.Kriens@aQute.biz|me]].
time=1314173350
title=01 Background
author:1314173350=
diff:1314173350:1288194748:=53,54c53,54%0a%3c The bnd program works on a higher level then traditional jarring; this might take some getting used to. However, it is much more elegant to think in packages than that it is to think in files. The fact that bnd understand the semantics of a bundle allows it to detect many errors and allows bundles to be created with almost no special information. %0a%3c %0a---%0a> The bnd program works on a higher level then traditional jarring; this might take some getting used to. However, it is much more elegant to think in packages than that it is to think in files. The fact that Bnd understand the semantics of a bundle allows it to detect many errors and allows bundles to be created with almost no special information. %0a> %0a58,67d57%0a%3c %0a%3c !!Tips%0a%3c There are some common pitfalls that can be prevented by following the tips:%0a%3c * Keep it simple. bnd's defaults are pretty good and not specifying is usually the best solution. KISS!%0a%3c * Think packages ... yes it feels redundant to specify the packages that are in your source directory but your artifact will get a life of its own over time. Many IDEs and build tools restricted us to one artifact per project but bnd allows many artifacts, allowing the choice of granularity to you. As OSGi's packages can be easily refactored you can design the contents of your artifacts depending on the deployment needs. Think packages!%0a%3c * Private is always better than export, only use export when you absolute need it.%0a%3c * Not versioning an exported package is at your own peril. Sorry, that is false, it is at the peril of your users.%0a%3c * Do not use the Bundle-ClassPath, if you need to include whole JARs, see the @ option at Include-Resource%0a%3c * If you do not understand a header, remove it%0a%3c * If you have a problem, make an example that is as small as possible and send it to [[mailto:Peter.Kriens@aQute.biz|me]].%0a\ No newline at end of file%0a
host:1314173350=90.41.251.99
author:1288194748=
diff:1288194748:1287384959:=57a58,102%0a> %0a> [[#quick]]%0a> !!Quick Start%0a> %0a> Assume we need to create a bundle in Eclipse. Each Java project in Eclipse has a set of sources and a class path. bnd therefore knows, about all the classes. However, it does not know how you want to structure your JARs/Bundles. It therefore needs a description file, the ''bnd file''. If you create such a file, you should give it the same as name as the bundle symbolic name with a @@.bnd@@ extension. For example @@aQute.example.bnd@@ is a well chosen name. If the name is not @@bnd.bnd@@, the file name without the .bnd extension is the default for your bundle symbolic name.%0a> %0a> Lets build a bundle for the aQute OSGi tutorial Chat example. This bundle has 2 packages.%0a> %0a> * aQute.service.channel%0a> * aQute.tutorial.chat%0a> %0a> The @@aQute.service.channel@@ package must be exported and the other package may remain private. All packages that are referred from the source code must be imported. To achieve this, the following manifest will suffice:%0a> %0a>   Export-Package: aQute.service.channel; version=1.0 %0a>   Private-Package: aQute.tutorial.chat%0a> %0a> This is all you need! In Eclipse, you can select the bnd file and run the @@Make Bundle@@ command. This will create a JAR with the proper content:%0a> %0a>  META-INF %0a>    MANIFEST.MF %0a>  aQute/service/channel %0a>    Channel.class %0a>    aQute/tutorial/chat %0a>    Chat$ChannelTracker.class %0a>    Chat.class%0a> %0a> You can run the same command from the command line%0a> %0a>  bnd aQute.tutorial.chat.bnd%0a> %0a> Now take a look at the JAR file's manifest. With the command line version of you can do this with @@bnd aQute.tutorial.chat.jar@@. Otherwise just open the JAR with WinZip.%0a> %0a>  Manifest-Version: 1%0a>  Bundle-Name: aQute.tutorial.chat%0a>  Private-Package: aQute.tutorial.chat%0a>  Import-Package: aQute.service.channel;version=1.0,%0a>    org.osgi.framework; version=1.3,%0a>    org.osgi.util.tracker;version=1.3%0a>  Bundle-ManifestVersion: 2%0a>  Bundle-SymbolicName: aQute.tutorial.chat%0a>  Export-Package: aQute.service.channel;version=1.0%0a>  Bundle-Version: 0%0a> %0a> As you can see, bnd filled in a number of headers. The first header, Manifest-Version is required by the JAR standard. Bundle-Name is derived from the Bundle-SymbolicName because we did not specify it. The Private-Package header specifies the packages that ended up not exported. The Import-Package header comes from the packages that were referred to from the contained packages (private and exported). As you can see, bnd picked up versions for the imported packages. These versions come from the manifest of the JARs that source these packages, or from the packageinfo file. The Export-Package shows the export of the service package. On top of this, bnd has verified that all your headers really match the OSGi specifications, or you will get errors and warnings.%0a> %0a
host:1288194748=90.41.125.248
author:1287384959=
diff:1287384959:1287249264:=6,9c6,9%0a%3c bnd is the Swiss army knife of OSGi, it is used for creating and working with OSGi bundles. Its primary goal is take the pain out of developing bundles. With OSGi you are forced to provide additional metadata in the JAR's manifest to verify the consistency of your "class path". This metadata must be closely aligned with the class files in the bundle and the policies that a company has about versioning. Maintaining this metdata is an error prone chore because many aspects are redundant.%0a%3c %0a%3c bnd's raison d'etre is therefore to remove the chores and use the redundancy to create the manifest from the class files instead of maintaining it by hand. The core task is therefore to analyze the class files and find any dependencies. These dependencies are then merged with ''instructions'' supplied by the user. For example, adding a version to all imported packages from a specific library can be specified as:%0a%3c %0a---%0a> bnd is the Swiss army knife for creating and working with OSGi bundles. Its primary goal is take the pain out of developing bundles. With OSGi you are forced to provide additional metadata in the JAR's manifest. This metadata must be closely aligned with the class files in the bundle and the policies that a company has about versioning. Maintaining this metdata is a chore that is also error prone because it is often redundant.%0a> %0a> bnd's raison d'etre is therefore to remove the chores and use the redundancy to create the manifest instead of maintaining it by hand. The core task is therefore to analyze the class files and find any dependencies. These dependencies are then merged with ''instructions'' supplied by the user. For example, adding a version to all imported packages from a specific library can be specified as:%0a> %0a12,13c12,13%0a%3c The OSGi manifest must explicitly mention a package, bnd allows the use of wildcards. bnd contains many more such conveniences. bnd roots are about 10 years old and bnd has therefore a large number of functions that remove such chores. These range from simplifying the use of OSGi Declarative Services, working with Spring and Blueprint, WAR and WAB files, version analysis, project dependencies, and much more.%0a%3c %0a---%0a> Where the OSGi manifest must explicitly mention a package, bnd allows the use of wildcards. However, bnd roots are about 10 years old and bnd has therefore a large number of functions that remove the chores of building bundles. These range from simplifying the use of OSGi Declarative Services, working with Spring and Blueprint, WAR and WAB files, version analysis, project dependencies, etc.%0a> %0a16,24c16,19%0a%3c !!Workflow%0a%3c Traditionally, JAR files were made with the JDK jar tool, the jar ant task, or the Maven packager. All these tools share the same concept. The developer creates a directory image of the jar by copying files to a directory; this directory is then jarred. This model can be called the ''push'' model. Obviously this method works well.%0a%3c %0a%3c bnd works differently, it uses the ''pull'' model. Instructions in the bnd file describe the contents of the desired JAR file without writing this structure to disk. The contents from the output can come from the class path or from anywhere in the file system. For example, the following instruction includes the designated packages in the JAR:%0a%3c %0a%3c   Private-Package: com.example.*%0a%3c  %0a%3c bnd can create a JAR from packages the sources, directories or other JAR files. You never have to copy files around, the instructions that Bnd receives are sufficient to retrieve the files from their original location, preprocessing or filtering when required.%0a%3c %0a---%0a> Traditionally, JAR files are made with the JDK jar tool, the jar ant task, or the Maven packager. All these tools share the same concept. The developer creates a directory image of the jar by copying files to a directory; this directory is then jarred. Obviously this method works well.%0a> %0a> bnd works different, it recognizes Java classes and packages and constructs the JAR from the classpath. It can create a JAR from packages the sources, directories or other JAR files. You never have to copy files around, the instructions that Bnd receives are sufficient to retrieve the files from their original location, preprocessing or filtering when required.%0a> %0a55,56c50,51%0a%3c bnd will not create an output file if none of the resources is newer than an existing output file.%0a%3c %0a---%0a> Bnd will not create an output file if none of the resources is newer than an existing output file.%0a> %0a62,63c57,58%0a%3c Assume we need to create a bundle in Eclipse. Each Java project in Eclipse has a set of sources and a class path. bnd therefore knows, about all the classes. However, it does not know how you want to structure your JARs/Bundles. It therefore needs a description file, the ''bnd file''. If you create such a file, you should give it the same as name as the bundle symbolic name with a @@.bnd@@ extension. For example @@aQute.example.bnd@@ is a well chosen name. If the name is not @@bnd.bnd@@, the file name without the .bnd extension is the default for your bundle symbolic name.%0a%3c %0a---%0a> Assume we need to create a bundle in Eclipse. Each Java project in Eclipse has a set of sources and a class path. Bnd therefore knows, about all the classes. However, it does not know how you want to structure your JARs/Bundles. It therefore needs a description file, the ''bnd file''. If you create such a file, you should give it the same as name as the bundle symbolic name with a @@.bnd@@ extension. For example @@aQute.example.bnd@@ is a well chosen name. If the name is not @@bnd.bnd@@, the file name without the .bnd extension is the default for your bundle symbolic name.%0a> %0a
host:1287384959=90.41.247.141
author:1287249264=
diff:1287249264:1287248470:=15a16,22%0a> I strongly suggest to use [[http://github.com/njbartlett/bndtools|bndtools]] from Neil Bartlett because this puts a very pretty Eclipse GUI on top of bnd.%0a> %0a> And now the most frequently asked question: ''How to pronounce and write bnd? bnd should be written with lower case characters because it is only modest tool. You pronounce it as be-and-de.''%0a> %0a> If you have questions about bnd then you can discuss these on the bndtools mailinglist: [[http://groups.google.com/group/bndtools-users|groups.google.com/group/bndtools-users]]. %0a> %0a> !bnd background%0a
host:1287249264=90.41.247.141
author:1287248470=
diff:1287248470:1287246186:=5d4%0a%3c !01 Background%0a
host:1287248470=90.41.247.141
author:1287246186=
diff:1287246186:1287246174:=1,2c1,2%0a%3c (:title 01 Background:)%0a%3c %0a---%0a> (:title bnd Background:)%0a> %0a
host:1287246186=90.41.247.141
author:1287246174=
diff:1287246174:1287246134:=2c2,3%0a%3c %0a---%0a> (:chapter: 1 :)%0a> %0a
host:1287246174=90.41.247.141
author:1287246134=
diff:1287246134:1287246067:=2,3c2,3%0a%3c (:chapter: 1 :)%0a%3c %0a---%0a> :chapter:1%0a> %0a
host:1287246134=90.41.247.141
author:1287246067=
diff:1287246067:1287246054:=2,3c2,3%0a%3c :chapter:1%0a%3c %0a---%0a> :chapter:1:%0a> %0a
host:1287246067=90.41.247.141
author:1287246054=
diff:1287246054:1287246001:=2,3c2,3%0a%3c :chapter:1:%0a%3c %0a---%0a> (:chapter:1:)%0a> %0a
host:1287246054=90.41.247.141
author:1287246001=
diff:1287246001:1287245063:=2,3c2%0a%3c (:chapter:1:)%0a%3c %0a---%0a> %0a
host:1287246001=90.41.247.141
author:1287245063=
diff:1287245063:1287244984:=5,20d4%0a%3c bnd is the Swiss army knife for creating and working with OSGi bundles. Its primary goal is take the pain out of developing bundles. With OSGi you are forced to provide additional metadata in the JAR's manifest. This metadata must be closely aligned with the class files in the bundle and the policies that a company has about versioning. Maintaining this metdata is a chore that is also error prone because it is often redundant.%0a%3c %0a%3c bnd's raison d'etre is therefore to remove the chores and use the redundancy to create the manifest instead of maintaining it by hand. The core task is therefore to analyze the class files and find any dependencies. These dependencies are then merged with ''instructions'' supplied by the user. For example, adding a version to all imported packages from a specific library can be specified as:%0a%3c %0a%3c   Import-Package: com.library.*; version = 1.21%0a%3c %0a%3c Where the OSGi manifest must explicitly mention a package, bnd allows the use of wildcards. However, bnd roots are about 10 years old and bnd has therefore a large number of functions that remove the chores of building bundles. These range from simplifying the use of OSGi Declarative Services, working with Spring and Blueprint, WAR and WAB files, version analysis, project dependencies, etc.%0a%3c %0a%3c Over time bnd started to appear in many different incarnations. It is an an ant task, a command line utility, and a bundle for Eclipse. Other projects have used bndlib to create a maven plugin, bndtools and Sigil both Eclipse IDEs, and others. By keeping the core library small and uncoupled (bnd has no external connections except Java 5), it is easy to embed the functionality in other projects.%0a%3c %0a%3c I strongly suggest to use [[http://github.com/njbartlett/bndtools|bndtools]] from Neil Bartlett because this puts a very pretty Eclipse GUI on top of bnd.%0a%3c %0a%3c And now the most frequently asked question: ''How to pronounce and write bnd? bnd should be written with lower case characters because it is only modest tool. You pronounce it as be-and-de.''%0a%3c %0a%3c If you have questions about bnd then you can discuss these on the bndtools mailinglist: [[http://groups.google.com/group/bndtools-users|groups.google.com/group/bndtools-users]]. %0a%3c %0a
host:1287245063=90.41.247.141
author:1287244984=
diff:1287244984:1287242878:=8,9c8,9%0a%3c bnd works different, it recognizes Java classes and packages and constructs the JAR from the classpath. It can create a JAR from packages the sources, directories or other JAR files. You never have to copy files around, the instructions that Bnd receives are sufficient to retrieve the files from their original location, preprocessing or filtering when required.%0a%3c %0a---%0a> The Bnd tool works different, it recognizes Java classes and packages and constructs the JAR from the classpath. It can create a JAR from packages the sources, directories or other JAR files. You never have to copy files around, the instructions that Bnd receives are sufficient to retrieve the files from their original location, preprocessing or filtering when required.%0a> %0a
host:1287244984=90.41.247.141
author:1287242878=
diff:1287242878:1287242280:=6,7c6,7%0a%3c Traditionally, JAR files are made with the JDK jar tool, the jar ant task, or the Maven packager. All these tools share the same concept. The developer creates a directory image of the jar by copying files to a directory; this directory is then jarred. Obviously this method works well.%0a%3c %0a---%0a> Traditionally, JAR files are made with the SUN jar tool, the jar ant task, or the Maven packager. All these tools share the same concept. The developer creates a directory image of the jar by copying files to a directory; this directory is then jarred. Obviously this method works well.%0a> %0a
host:1287242878=90.41.247.141
author:1287242280=
diff:1287242280:1287242259:=2,4d1%0a%3c %0a%3c http://www.aqute.biz/uploads/Code/bnd.png%0a%3c %0a
host:1287242280=90.41.247.141
author:1287242259=
diff:1287242259:1287242259:=1,84d0%0a%3c (:title bnd Background:)%0a%3c !bnd background%0a%3c Traditionally, JAR files are made with the SUN jar tool, the jar ant task, or the Maven packager. All these tools share the same concept. The developer creates a directory image of the jar by copying files to a directory; this directory is then jarred. Obviously this method works well.%0a%3c %0a%3c The Bnd tool works different, it recognizes Java classes and packages and constructs the JAR from the classpath. It can create a JAR from packages the sources, directories or other JAR files. You never have to copy files around, the instructions that Bnd receives are sufficient to retrieve the files from their original location, preprocessing or filtering when required.%0a%3c %0a%3c The Jar is constructed from 3 different arguments:%0a%3c %0a%3c   Export-Package%0a%3c   Private-Package%0a%3c   Include-Resource%0a%3c %0a%3c Private-Package and Export-Package contain ''instructions''. Instructions are patterns + attributes and directives, looking like normal OSGi attributes and directives. For example:%0a%3c %0a%3c   Export-Package: com.acme.*;version=1.2%0a%3c %0a%3c Each instruction is applied to each package on the classpath in the definition order. That is, if an earlier instruction matches, the later instruction never gets a chance to do its work. If an instruction matches its attributes and properties are applied to the packages. The difference between the Private-Package argument and the Export-Package arguments is that the export version selects the packages for export. If the packages overlap between the two, the export wins.%0a%3c %0a%3c An instruction can also be negative when it starts with a '!'. In that case the package is excluded from the selection. For example:%0a%3c %0a%3c   Export-Package: !com.acme.impl, com.acme.*;version=1.2%0a%3c %0a%3c Note that the instructions are applied in order. If the ! instruction was at the end in the previous example, it would not have done its work because the com.acme.* would already have matched.%0a%3c %0a%3c The Include-Resource argument can be used to copy resources from the file system in the JAR. This is useful for licenses, images, etc. The instructions in the argument can be a directory, a file, or an inline JAR. The default JAR path is the the root for a directory or the filename for a file. The path can be overridden. Instructions that are enclosed in curly braces, like {license.txt}, are pre-processed, expanding any macros in the file.%0a%3c %0a%3c Once the JAR is created, the bnd program analyzes the classes and creates an import list with all the packages that are not contained in the jar but which are referred to. This import list is matched against the Import-Package instructions. Normally, the Import-Package argument is *; all referred packages will be imported. However, sometimes it is necessary to ignore an import or provide attributes on the import statement. For example, make the import optional or discard the import:%0a%3c %0a%3c   Import-Package: !com.acme.*, *;resolution:=optional%0a%3c %0a%3c The arguments to bnd are normal given as a set of properties. Properties that begin with an upper case are copied to the manifest (possibly after processing). Lower case properties are used for macro variables but are not set as headers in the manifest.%0a%3c %0a%3c After the JAR is created, the bnd program will verify the result. This will check the resulting manifest in painstaking detail.%0a%3c %0a%3c The bnd program works on a higher level then traditional jarring; this might take some getting used to. However, it is much more elegant to think in packages than that it is to think in files. The fact that Bnd understand the semantics of a bundle allows it to detect many errors and allows bundles to be created with almost no special information. %0a%3c %0a%3c Bnd will not create an output file if none of the resources is newer than an existing output file.%0a%3c %0a%3c The program is available in several forms: command line, ant task, maven plugin, and an Eclipse plugin.%0a%3c %0a%3c [[#quick]]%0a%3c !!Quick Start%0a%3c %0a%3c Assume we need to create a bundle in Eclipse. Each Java project in Eclipse has a set of sources and a class path. Bnd therefore knows, about all the classes. However, it does not know how you want to structure your JARs/Bundles. It therefore needs a description file, the ''bnd file''. If you create such a file, you should give it the same as name as the bundle symbolic name with a @@.bnd@@ extension. For example @@aQute.example.bnd@@ is a well chosen name. If the name is not @@bnd.bnd@@, the file name without the .bnd extension is the default for your bundle symbolic name.%0a%3c %0a%3c Lets build a bundle for the aQute OSGi tutorial Chat example. This bundle has 2 packages.%0a%3c %0a%3c * aQute.service.channel%0a%3c * aQute.tutorial.chat%0a%3c %0a%3c The @@aQute.service.channel@@ package must be exported and the other package may remain private. All packages that are referred from the source code must be imported. To achieve this, the following manifest will suffice:%0a%3c %0a%3c   Export-Package: aQute.service.channel; version=1.0 %0a%3c   Private-Package: aQute.tutorial.chat%0a%3c %0a%3c This is all you need! In Eclipse, you can select the bnd file and run the @@Make Bundle@@ command. This will create a JAR with the proper content:%0a%3c %0a%3c  META-INF %0a%3c    MANIFEST.MF %0a%3c  aQute/service/channel %0a%3c    Channel.class %0a%3c    aQute/tutorial/chat %0a%3c    Chat$ChannelTracker.class %0a%3c    Chat.class%0a%3c %0a%3c You can run the same command from the command line%0a%3c %0a%3c  bnd aQute.tutorial.chat.bnd%0a%3c %0a%3c Now take a look at the JAR file's manifest. With the command line version of you can do this with @@bnd aQute.tutorial.chat.jar@@. Otherwise just open the JAR with WinZip.%0a%3c %0a%3c  Manifest-Version: 1%0a%3c  Bundle-Name: aQute.tutorial.chat%0a%3c  Private-Package: aQute.tutorial.chat%0a%3c  Import-Package: aQute.service.channel;version=1.0,%0a%3c    org.osgi.framework; version=1.3,%0a%3c    org.osgi.util.tracker;version=1.3%0a%3c  Bundle-ManifestVersion: 2%0a%3c  Bundle-SymbolicName: aQute.tutorial.chat%0a%3c  Export-Package: aQute.service.channel;version=1.0%0a%3c  Bundle-Version: 0%0a%3c %0a%3c As you can see, bnd filled in a number of headers. The first header, Manifest-Version is required by the JAR standard. Bundle-Name is derived from the Bundle-SymbolicName because we did not specify it. The Private-Package header specifies the packages that ended up not exported. The Import-Package header comes from the packages that were referred to from the contained packages (private and exported). As you can see, bnd picked up versions for the imported packages. These versions come from the manifest of the JARs that source these packages, or from the packageinfo file. The Export-Package shows the export of the service package. On top of this, bnd has verified that all your headers really match the OSGi specifications, or you will get errors and warnings.%0a%3c %0a
host:1287242259=90.41.247.141
