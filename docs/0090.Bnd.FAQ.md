version=pmwiki-2.1.18 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:7.0) Gecko/20100101 Firefox/7.0
author=
csum=
ctime=1288248366
host=90.41.251.99
name=Bnd.FAQ
rev=15
targets=Bnd.Bndtools
text=(:title 99 FAQ:)%0a%0a%0a!Frequently Asked Questions%0a%0a* [[#howToAsk|How to Ask a Question]]%0a* [[#tooManyImports|Too Many Imports]]%0a* [[#removeImports|Remove unwanted imports]]%0a* [[#importingDefaultPackage|Importing Default Package]]%0a* [[#automaticActivator|Why No Automatic Bundle-Activator]]%0a* [[#unbindMethod|How to set the unbind method with @Reference?]]%0a* [[#packageinfo|packageinfo or package-info.java]]%0a* [[#supercomps|Why are super classes not inspected for annotations?]]%0a* [[#exportversions|Where do the exported package versions come from?]]%0a* [[#bundleclasspath|Should I use the Bundle-ClassPath?]]%0a* [[#bundleclasspath2|What Should I use instead of the Bundle-ClassPath?]]%0a----%0a[[#howToAsk]]%0a!!How to ask a question%0aYou can send a mail to [[http://groups.google.com/group/bndtools-users/|bndtools users]] or [[mailto:Peter.Kriens@aQute.biz|mail me]].%0a%0a%0a----%0a[[#tooManyImports]]%0a!!Too Many Imports%0aSometimes bnd reports imports that seem plain wrong. Believe me, they are almost always right. bnd does a thorough analysis of the byte codes in your class files and when it imports something it is almost sure to be a reference in your code. How can you find the culprit? [[Bndtools]] has tooling to drill down into your code. bnd also can print out the JAR and look at the @@[USEDBY]@@ section to find the package(s) that cause the import.%0a%0aIf there is no package using the imported package, then look at the following places for imports:%0a%0a* Spring/Blueprint XML%0a* Bundle Activator%0a* Component annotations or Service-Component headers%0a%0aIn the likely case the import is real but unwanted, look at [[#removeUnwantedImports|Unwanted Imports]].%0a%0a----%0a[[#importingDefaultPackage]]%0a!!Importing the default package error%0aThis usually indicates that:%0a%0a* You include classes that have compile errors. Some compilers still create class files on errors but they are invalid.%0a* One of the imports caused by Spring, Blueprint, or Service Components are not proper.%0a%0a----%0a[[#removeUnwantedImports]]%0a!!Remove unwanted imports%0aIf you have an unwanted import than you can remove it from the Import-Package manifest header with the '!' operator:%0a%0a  Import-Package: !com.unwanted.reference.*, *%0a%0aA usually better way is to make the imports optional:%0a%0a  Import-Package: com.unwanted.reference.*;optional:=true, *%0a%0aNote the end at the Import-Package statement, that wildcard '*' is crucial for remaining imports, see [[#noImports|No Imports Show Up]].%0a%0a----%0a[[#noImports]]%0a!!No Imports Show Up%0aThe imports that show up in your Import-Package manifest header are controlled by the bnd file's Import-Package instruction. In bnd, the list is a set of patterns that are sequentially applied to your imports as calculated by bnd from the classes, resources, and headers in the JAR.%0a%0aThe default Import-Package bnd instruction is:%0a%0a  Import-Package: *%0a%0aThis imports all referred packages. The most common reasons imports do not appear in the manifest is that the default is overridden and the overrider forgot to add the wildcard '*' at the end. For example, the following is wrong:%0a%0a  Import-Package: com.example; version=1.2%0a%0aThis will create an import for com.example but it ignores all other imports.%0a%0aAnother reason is the exclude operator ('!') that will remove imports. If this is too wild, then no imports are left to insert in the manifest. So the following leads to no imports for any package starting with com.example.%0a%0a  Import-Package: !com.example.*, *%0a%0aLast but not least, look at the @@[USEDBY]@@ section of the JAR print out, make sure there are actually references.%0a%0a----%0a[[#automaticActivator]]%0a!!Why No Automatic Bundle-Activator%0aMany people are surprised that bnd does not automatically calculate the Bundle-Activator. Basically, there are the following issues:%0a%0a* Not all bundles have a bundle activator%0a* Detecting an activator in the code does not always mean you want one%0a* Detecting means you can find more than one%0a%0aThat said, it is possible to automate the Bundle-Activator:%0a%0a  Bundle-Activator: \%0a   ${classes;IMPLEMENTS;org.osgi.framework.BundleActivator}%0a%0aHowever, if there are multiple Bundle-Activators you will get an error.%0a%0a----%0a[[#unbindMethod]]%0a!!How to assign an unbind method to a @Reference?%0a@@@Reference@@ automatically sets the bind method but how is the unbind method set? Simple, you use a method with a similar name:%0a%0a%0a||!bind||!unbind||%0a||@@setX@@ ||@@unsetX@@||%0a||@@addX@@ ||@@removeX@@||%0aFor example:%0a  @Reference%0a  protected void setFoo(LogService l) { ... }%0a  protected void unsetFoo(LogService l) { ... }%0aIf you want to override this, use%0a  @Reference(unbind="IRefuseToCallMyMethodUnFoo");%0a  protected void foo(LogService l) {}%0a  protected void IRefuseToCallMyMethodUnFoo(LogService l) {}%0aUnfortunately Java has no method references so it is not type safe.A non existent @@@UnReference@@ annotation is not very useful because that still requires linking it up symbolically to the associated @@@Reference@@.%0a%0a[[#packageinfo]]%0a!!packageinfo or package-info.java?%0aInspired by the osgi-dev thread [[http://www.mail-archive.com/osgi-dev@mail.osgi.org/msg01514.html|Why default version for Export-Package is 0.0.0, not bundle version?]] I'm just a little bit confused about the bnd approach with the file naming "packageinfo". The [[http://java.sun.com/docs/books/jls/third_edition/html/packages.html|JLS]] already defines "package-info.java" for package relevant infos. Wouldn't it be simplier (less complex) to have only one file for package definitions? So, the bnd tool could manage the package version in "package-info.java", too.%0a%0aYou can use either file. The reason there are two options is that one constituency thinks annotations are the only solution and the other is running pre Java 5 ... Basically if I would have to choose it would be packageinfo because that works anywhere but I expect that you probably would not like that :-) %0a%0a[[#supercomps]]%0a!!Why are superclass not inspected for Component annotations?%0aAnnotations are not inherited form the component's super classes. The problem is that bnd cannot in all cases can see super classes (and interfaces) because the super class does not have to be available in the build. In runtime you are sure the super class is there, at build time you do not have that luxury. So to make sure, always define your annotations on the actual component class.%0a%0a[[#exportversions]]%0a!!Can't find the source of the version on an Export-Package?%0aIf no explicit export version is specified in the bnd file then bnd will look in the following places.%0a%0a# packageinfo file in the package directory (recommended)%0a# package-info.java, bnd's Version annotation%0a# Manifest of the exporting JAR%0a%0aThere was a mis-feature in an [[http://www.mail-archive.com/users@felix.apache.org/msg09656.html|older version of the maven plugin]] that appended the pom version to the exported packages. It looked professional but it was baloney. Versioning a bundle should not version a package automatically, try it and feel the pain. So if you can't find the source of an exported package version you might have an old maven bundle plugin. %0a%0a[[#bundleclasspath]]%0a!!Should I use the Bundle-ClassPath?%0aNo. It creates unnecessary complexity, it is slower, and it is not necessary. It will also not be compatible with techniques like [[http://code.google.com/p/pojosr|PojoSR]], something that the OSGi is looking into standardizing.%0a%0a[[#bundleclasspath2]]%0a!!What should I use instead of the Bundle-ClassPath?%0aJust use Private-Package and Export-Package, know what goes into your JAR. If you really need to wrap one or more JARs, use the Include-Resource instruction, it has an option to unroll a JAR resource (see [[#include-resource|@ option]]). This will copy all its contents in the target JAR. The -exportcontents can then be used to export selected packages. Even better is of course to know %0a%0a-----%0aIf an entry is wrong, send a [[mailto:bnd@aQute.biz|mail]] with the JAR that has the problem. Preferably as small as possible.%0a%0a
time=1314174083
title=99 FAQ
author:1314174083=
diff:1314174083:1298467188:=13,16c13%0a%3c * [[#supercomps|Why are super classes not inspected for annotations?]]%0a%3c * [[#exportversions|Where do the exported package versions come from?]]%0a%3c * [[#bundleclasspath|Should I use the Bundle-ClassPath?]]%0a%3c * [[#bundleclasspath2|What Should I use instead of the Bundle-ClassPath?]]%0a---%0a> * [[#supercomps]]|Why are super classes not inspected for annotations?]]%0a123,140d119%0a%3c [[#exportversions]]%0a%3c !!Can't find the source of the version on an Export-Package?%0a%3c If no explicit export version is specified in the bnd file then bnd will look in the following places.%0a%3c %0a%3c # packageinfo file in the package directory (recommended)%0a%3c # package-info.java, bnd's Version annotation%0a%3c # Manifest of the exporting JAR%0a%3c %0a%3c There was a mis-feature in an [[http://www.mail-archive.com/users@felix.apache.org/msg09656.html|older version of the maven plugin]] that appended the pom version to the exported packages. It looked professional but it was baloney. Versioning a bundle should not version a package automatically, try it and feel the pain. So if you can't find the source of an exported package version you might have an old maven bundle plugin. %0a%3c %0a%3c [[#bundleclasspath]]%0a%3c !!Should I use the Bundle-ClassPath?%0a%3c No. It creates unnecessary complexity, it is slower, and it is not necessary. It will also not be compatible with techniques like [[http://code.google.com/p/pojosr|PojoSR]], something that the OSGi is looking into standardizing.%0a%3c %0a%3c [[#bundleclasspath2]]%0a%3c !!What should I use instead of the Bundle-ClassPath?%0a%3c Just use Private-Package and Export-Package, know what goes into your JAR. If you really need to wrap one or more JARs, use the Include-Resource instruction, it has an option to unroll a JAR resource (see [[#include-resource|@ option]]). This will copy all its contents in the target JAR. The -exportcontents can then be used to export selected packages. Even better is of course to know %0a%3c %0a
host:1314174083=90.41.251.99
author:1298467188=
diff:1298467188:1298466737:=13d12%0a%3c * [[#supercomps]]|Why are super classes not inspected for annotations?]]%0a112,113c111,112%0a%3c Inspired by the osgi-dev thread [[http://www.mail-archive.com/osgi-dev@mail.osgi.org/msg01514.html|Why default version for Export-Package is 0.0.0, not bundle version?]] I'm just a little bit confused about the bnd approach with the file naming "packageinfo". The [[http://java.sun.com/docs/books/jls/third_edition/html/packages.html|JLS]] already defines "package-info.java" for package relevant infos. Wouldn't it be simplier (less complex) to have only one file for package definitions? So, the bnd tool could manage the package version in "package-info.java", too.%0a%3c %0a---%0a> Inspired by the osgi-dev thread [[http://www.mail-archive.com/osgi-dev@mail.osgi.org/msg01514.html|Why default version for Export-Package is 0.0.0, not bundle version?]] I'm just a little bit confused about the bnd approach with the file naming "packageinfo". The JLS (http://java.sun.com/docs/books/jls/third_edition/html/packages.html 7.4ff) already defines "package-info.java" for package relevant infos. Wouldn't it be simplier (less complex) to have only one file for package definitions? So, the bnd tool could manage the package version in "package-info.java", too.%0a> %0a116,120d114%0a%3c [[#supercomps]]%0a%3c !!Why are superclass not inspected for Component annotations?%0a%3c Annotations are not inherited form the component's super classes. The problem is that bnd cannot in all cases can see super classes (and interfaces) because the super class does not have to be available in the build. In runtime you are sure the super class is there, at build time you do not have that luxury. So to make sure, always define your annotations on the actual component class.%0a%3c %0a%3c -----%0a
host:1298467188=90.37.148.75
author:1298466737=
diff:1298466737:1289483615:=12c12,14%0a%3c * [[#packageinfo|packageinfo or package-info.java]]%0a---%0a> %0a> If an entry is wrong, send a [[mailto:bnd@aQute.biz|mail]] with the JAR that has the problem. Preferably as small as possible.%0a> %0a108,116d109%0a%3c %0a%3c [[#packageinfo]]%0a%3c !!packageinfo or package-info.java?%0a%3c Inspired by the osgi-dev thread [[http://www.mail-archive.com/osgi-dev@mail.osgi.org/msg01514.html|Why default version for Export-Package is 0.0.0, not bundle version?]] I'm just a little bit confused about the bnd approach with the file naming "packageinfo". The JLS (http://java.sun.com/docs/books/jls/third_edition/html/packages.html 7.4ff) already defines "package-info.java" for package relevant infos. Wouldn't it be simplier (less complex) to have only one file for package definitions? So, the bnd tool could manage the package version in "package-info.java", too.%0a%3c %0a%3c You can use either file. The reason there are two options is that one constituency thinks annotations are the only solution and the other is running pre Java 5 ... Basically if I would have to choose it would be packageinfo because that works anywhere but I expect that you probably would not like that :-) %0a%3c %0a%3c If an entry is wrong, send a [[mailto:bnd@aQute.biz|mail]] with the JAR that has the problem. Preferably as small as possible.%0a%3c %0a
host:1298466737=90.37.148.75
author:1289483615=
diff:1289483615:1289483591:=100a101%0a> %0a101a103%0a> %0a104a107%0a> %0a105a109%0a> %0a108a113%0a> %0a
host:1289483615=90.41.84.94
author:1289483591=
diff:1289483591:1289483545:=99,103c99,101%0a%3c ||@@setX@@ ||@@unsetX@@||%0a%3c ||@@addX@@ ||@@removeX@@||%0a%3c %0a%3c For example:%0a%3c %0a---%0a> ||setX ||unsetX||%0a> ||addX ||removeX||%0a> %0a
host:1289483591=90.41.84.94
author:1289483545=
diff:1289483545:1289483496:=11,12c11%0a%3c * [[#unbindMethod|How to set the unbind method with @Reference?]]%0a%3c %0a---%0a> %0a
host:1289483545=90.41.84.94
author:1289483496=
diff:1289483496:1288250085:=90,111d89%0a%3c %0a%3c ----%0a%3c [[#unbindMethod]]%0a%3c !!How to assign an unbind method to a @Reference?%0a%3c @@@Reference@@ automatically sets the bind method but how is the unbind method set? Simple, you use a method with a similar name:%0a%3c %0a%3c %0a%3c ||!bind||!unbind||%0a%3c ||setX ||unsetX||%0a%3c ||addX ||removeX||%0a%3c %0a%3c   @Reference%0a%3c   protected void setFoo(LogService l) { ... }%0a%3c   protected void unsetFoo(LogService l) { ... }%0a%3c %0a%3c If you want to override this, use%0a%3c %0a%3c   @Reference(unbind="IRefuseToCallMyMethodUnFoo");%0a%3c   protected void foo(LogService l) {}%0a%3c   protected void IRefuseToCallMyMethodUnFoo(LogService l) {}%0a%3c %0a%3c Unfortunately Java has no method references so it is not type safe.A non existent @@@UnReference@@ annotation is not very useful because that still requires linking it up symbolically to the associated @@@Reference@@.%0a
host:1289483496=90.41.84.94
author:1288250085=
diff:1288250085:1288250055:=6c6%0a%3c * [[#howToAsk|How to Ask a Question]]%0a---%0a> * [[howToAsk|How to Ask a Question]]%0a76c76%0a%3c [[#automaticActivator]]%0a---%0a> [[##automaticActivator]]%0a
host:1288250085=90.41.125.248
author:1288250055=
diff:1288250055:1288249358:=10,11c10%0a%3c * [[#automaticActivator|Why No Automatic Bundle-Activator]]%0a%3c %0a---%0a> %0a74,89d72%0a%3c %0a%3c ----%0a%3c [[##automaticActivator]]%0a%3c !!Why No Automatic Bundle-Activator%0a%3c Many people are surprised that bnd does not automatically calculate the Bundle-Activator. Basically, there are the following issues:%0a%3c %0a%3c * Not all bundles have a bundle activator%0a%3c * Detecting an activator in the code does not always mean you want one%0a%3c * Detecting means you can find more than one%0a%3c %0a%3c That said, it is possible to automate the Bundle-Activator:%0a%3c %0a%3c   Bundle-Activator: \%0a%3c    ${classes;IMPLEMENTS;org.osgi.framework.BundleActivator}%0a%3c %0a%3c However, if there are multiple Bundle-Activators you will get an error.%0a
host:1288250055=90.41.125.248
author:1288249358=
diff:1288249358:1288249271:=11,12d10%0a%3c If an entry is wrong, send a [[mailto:bnd@aQute.biz|mail]] with the JAR that has the problem. Preferably as small as possible.%0a%3c %0a29a28,29%0a> If you're sure the import is wrong, send a [[mailto:bnd@aQute.biz|mail]] with the JAR that gives you the wrong import.%0a> %0a
host:1288249358=90.41.125.248
author:1288249271=
diff:1288249271:1288249253:=14,16c14,16%0a%3c You can send a mail to [[http://groups.google.com/group/bndtools-users/|bndtools users]] or [[mailto:Peter.Kriens@aQute.biz|mail me]].%0a%3c %0a%3c %0a---%0a> You can send a mail to [[http://groups.google.com/group/bndtools-users/|bndtools users]] or [[mailto:Peter.Kriens@aQute.biz]].%0a> %0a> %0a
host:1288249271=90.41.125.248
author:1288249253=
diff:1288249253:1288249218:=32d31%0a%3c ----%0a
host:1288249253=90.41.125.248
author:1288249218=
diff:1288249218:1288249146:=7c7%0a%3c * [[#tooManyImports|Too Many Imports]]%0a---%0a> * [[#tooManyImports|Unneeded Imports]]%0a11c11%0a%3c ----%0a---%0a> %0a17d16%0a%3c ----%0a39d37%0a%3c ----%0a52d49%0a%3c ----%0a
host:1288249218=90.41.125.248
author:1288249146=
diff:1288249146:1288248366:=8d7%0a%3c * [[#removeImports|Remove unwanted imports]]%0a27,30d25%0a%3c If you're sure the import is wrong, send a [[mailto:bnd@aQute.biz|mail]] with the JAR that gives you the wrong import.%0a%3c %0a%3c In the likely case the import is real but unwanted, look at [[#removeUnwantedImports|Unwanted Imports]].%0a%3c %0a37,68d31%0a%3c %0a%3c [[#removeUnwantedImports]]%0a%3c !!Remove unwanted imports%0a%3c If you have an unwanted import than you can remove it from the Import-Package manifest header with the '!' operator:%0a%3c %0a%3c   Import-Package: !com.unwanted.reference.*, *%0a%3c %0a%3c A usually better way is to make the imports optional:%0a%3c %0a%3c   Import-Package: com.unwanted.reference.*;optional:=true, *%0a%3c %0a%3c Note the end at the Import-Package statement, that wildcard '*' is crucial for remaining imports, see [[#noImports|No Imports Show Up]].%0a%3c %0a%3c [[#noImports]]%0a%3c !!No Imports Show Up%0a%3c The imports that show up in your Import-Package manifest header are controlled by the bnd file's Import-Package instruction. In bnd, the list is a set of patterns that are sequentially applied to your imports as calculated by bnd from the classes, resources, and headers in the JAR.%0a%3c %0a%3c The default Import-Package bnd instruction is:%0a%3c %0a%3c   Import-Package: *%0a%3c %0a%3c This imports all referred packages. The most common reasons imports do not appear in the manifest is that the default is overridden and the overrider forgot to add the wildcard '*' at the end. For example, the following is wrong:%0a%3c %0a%3c   Import-Package: com.example; version=1.2%0a%3c %0a%3c This will create an import for com.example but it ignores all other imports.%0a%3c %0a%3c Another reason is the exclude operator ('!') that will remove imports. If this is too wild, then no imports are left to insert in the manifest. So the following leads to no imports for any package starting with com.example.%0a%3c %0a%3c   Import-Package: !com.example.*, *%0a%3c %0a%3c Last but not least, look at the @@[USEDBY]@@ section of the JAR print out, make sure there are actually references.%0a
host:1288249146=90.41.125.248
author:1288248366=
diff:1288248366:1288248366:=1,31d0%0a%3c (:title 99 FAQ:)%0a%3c %0a%3c %0a%3c !Frequently Asked Questions%0a%3c %0a%3c * [[howToAsk|How to Ask a Question]]%0a%3c * [[#tooManyImports|Unneeded Imports]]%0a%3c * [[#importingDefaultPackage|Importing Default Package]]%0a%3c %0a%3c %0a%3c [[#howToAsk]]%0a%3c !!How to ask a question%0a%3c You can send a mail to [[http://groups.google.com/group/bndtools-users/|bndtools users]] or [[mailto:Peter.Kriens@aQute.biz]].%0a%3c %0a%3c %0a%3c [[#tooManyImports]]%0a%3c !!Too Many Imports%0a%3c Sometimes bnd reports imports that seem plain wrong. Believe me, they are almost always right. bnd does a thorough analysis of the byte codes in your class files and when it imports something it is almost sure to be a reference in your code. How can you find the culprit? [[Bndtools]] has tooling to drill down into your code. bnd also can print out the JAR and look at the @@[USEDBY]@@ section to find the package(s) that cause the import.%0a%3c %0a%3c If there is no package using the imported package, then look at the following places for imports:%0a%3c %0a%3c * Spring/Blueprint XML%0a%3c * Bundle Activator%0a%3c * Component annotations or Service-Component headers%0a%3c %0a%3c [[#importingDefaultPackage]]%0a%3c !!Importing the default package error%0a%3c This usually indicates that:%0a%3c %0a%3c * You include classes that have compile errors. Some compilers still create class files on errors but they are invalid.%0a%3c * One of the imports caused by Spring, Blueprint, or Service Components are not proper.%0a
host:1288248366=90.41.125.248
