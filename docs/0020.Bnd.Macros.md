version=pmwiki-2.1.18 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.6; en-US; rv:1.9.2.13) Gecko/20101203 Firefox/3.6.13
author=
csum=
ctime=1287242539
host=90.37.148.75
name=Bnd.Macros
rev=23
targets=
text=(:title 05 Macros :)%0a%0ahttp://www.aqute.biz/uploads/Code/bnd.png%0a%0a!05 Macros%0a%0aA simple macro processor is added to the header processing. Variables allow a single definition of a value, and the use of derivations. Each header is a macro that can be expanded. Notice that headers that do not start with an upper case character will not be copied to the manifest, so they can be used as working variables. Variables are expanded by enclosing the name of the variable in @@${%3cname>}@@ (curly braces) or @@$(%3cname>)@@ (parenthesis). Additionally, square brackets [], angled brackets %3c>, double guillemets «», and single guillemets ‹› are also allowed for brackets. If brackets are nested, that is $[replace;acaca;a(.*)a;[$1]] will return @@[cac]@@.%0a%0aFor example:%0a%0a version=1.23.87.200109111023542%0a Bundle-Version= ${version}%0a Bundle-Description= This bundle has version ${version}%0a%0aThere are also a number of macros that perform basic functions. All these functions have the following basic syntax:%0a%0a macro ::= '${' function '}' %0a         | '$[' function ']'%0a         | '$(' function ')'%0a         | '$%3c' function '>'%0a%0a function ::= name ( ':' argument ) *%0a%0a(:table:)%0a(:cell:)'''Function'''%0a(:cell:)'''Arguments'''%0a(:cell:)'''Description'''%0a%0a%0a(:cellnr:)[[#basename]]@@basename@@%0a(:cell:)@@arg ( ';' arg )*@@%0a(:cell:)Return a comma separated list with all the file names (not directory) of the arguments. Non existent files are skipped.%0a%0a(:cellnr:)[[#cat]]@@cat@@%0a(:cell:)@@arg@@%0a(:cell:)If arg is a directory, return the contents of the directory. If it is a file, return the contents of the file.%0a%0a(:cellnr:)[[#classes]]@@classes@@%0a(:cell:)QUERY%0a(:cell:)Provides a query function to find classes to fulfill certain criteria. See the [[#classesx|classes]] macro%0a%0a(:cellnr:)[[#env]]@@env@@%0a(:cell:); name%0a(:cell:)Provide the value of the given environment variable%0a%0a(:cellnr:)[[#def]]@@def@@%0a(:cell:)@@arg@@%0a(:cell:)Provide the empty string if arg is not defined, otherwise it provides the value of the property @@arg@@.%0a%0a(:cellnr:)[[#dir]]@@dir@@%0a(:cell:)@@arg ( ';' arg ) *%0a(:cell:)Get the directory names of the arguments in a comma separated format. For example, ${dir;${project}} should provide the directory path (absolute) of the directory that contains the project%0a%0a(:cellnr:)[[#error]]@@error@@%0a(:cell:)@@arg ( ';' arg ) *@@%0a(:cell:)Generate an error for each @@arg@@.%0a%0a(:cellnr:)[[#if]]@@if@@%0a(:cell:); condition ; true ( ; false ) ? %0a(:cell:)If the condition is not empty, the true part is returned, else the false part is returned. If not false part is supplied, the empty string is returned. The condition is trimmed before tested. For example:%0a%0a  Comment: ${if;${version};Ok;Version is NOT set!!!!}%0a%0a(:cellnr:)[[#isdir]]@@isdir@@%0a(:cell:)@@arg@@%0a(:cell:)Returns "true" when arg is an existing directory, otherwise "false".%0a%0a(:cellnr:)[[#isfile]]@@isfile@@%0a(:cell:)@@arg@@%0a(:cell:)Returns "true" when arg is an existing file, otherwise "false".%0a%0a(:cellnr:)[[#filter]]@@filter@@%0a(:cell:)';' list ';' regex%0a(:cell:)The filter macro iterates over the given list and only includes elements that match the given regular expression (regex). The following example includes only the jar files from the list: \\%0a@@list= a,b,c,d,x.jar,z.jar \\%0aList= ${filter;${list};.*\\.jar}@@%0a%0a(:cellnr:)[[#filterout]]@@filterout@@%0a(:cell:); list ; regex%0a(:cell:)The filterout macro iterates over the given list and removes elements that match the given regular expression (regex). The following example strips the jar files from the list:  \\%0a@@list= a,b,c,d,x.jar,z.jar \\%0aList= ${filterout:${list};.*\\.jar}@@%0a%0a(:cellnr:)[[#findname]]@@findname@@%0a(:cell:); regex [ ; replacement ]  %0a(:cell:)Find the paths to any resources that matches the regular expression, replace the name with the replacement of the regex. Notice that the regex is only executed on the name of the resource, that is, without the slashes.%0a%0a(:cellnr:)[[#findpath]]@@findpath@@%0a(:cell:); regex [ ; replacement ]  %0a(:cell:)Find the paths to any resources that matches the regular expression, replace the path with the replacement of the regex. Notice that the regex is executed on the path of the resource, that is, with the slashes.%0a%0a(:cellnr:)[[#fmodified]]@@fmodified@@%0a(:cell:); file-path-list %0a(:cell:)Return the highest modification time of the given file path. The returned value is based on the epoch of Java, it is therefore a long.  \\%0a@@Last-Modified: ${long2date;${fmodified;${files}})@@%0a%0a(:cellnr:)[[#join]]@@join@@%0a(:cell:)( ; list ) *%0a(:cell:)Joins a number of lists into one. It may seem that this can be easily accomplished by just placing two macro expansions after each other. The result of this will not be a list, unless a ',' (colon) is placed in between. However, when one of the lists is empty, the colon will be superfluous. The join handles these cases correctly. Any number of lists may be given as arguments. \\%0a@@List= ${join;a,b,c;d,e,f}@@%0a%0a(:cellnr:)[[#literal]]@@literal@@%0a(:cell:)@@arg@@%0a(:cell:)Provide a literal macro for arg. For example, @@${literal;"project"}@@ results in @@"${project}"@@. Can be useful if information must be created for other systems that uses the macro syntax.%0a%0a(:cellnr:)[[#lsa]]@@lsa@@%0a(:cell:)@@dir@@ ( ';' PATTERN ( ',' PATTERN )* )?%0a(:cell:)Return the contents of the given directory filtered by the patterns. The result is a comma separated list of absolute file names.%0a%0a(:cellnr:)[[#lsr]]@@lsr@@%0a(:cell:)@@dir@@ ( ';' PATTERN ( ',' PATTERN )* )?%0a(:cell:)Return the contents of the given directory filtered by the patterns. The result is a comma separated list of relative file names.%0a%0a(:cellnr:)[[#long2date]]@@long2date@@%0a(:cell:); long %0a(:cell:)Parse the long and turn it into a date.  \\%0a@@Last-Modified: ${long2date:${fmodified:${files}})@@%0a%0a(:cellnr:)[[#now]]@@now@@%0a(:cell:)%0a(:cell:)Returns the current Date as string.  \\%0a@@Created-When: ${now}@@%0a%0a(:cellnr:)[[#osfile]]@@osfile@@%0a(:cell:)@@base (';' PATH )*@@%0a(:cell:)Return a comma separated list of absolute file paths in the current's OS' format. If the PATH is relative, it is calculated from the base directory.%0a%0a(:cellnr:)[[#path]]@@path@@%0a(:cell:)LIST (';' LIST )*@@%0a(:cell:)Return a platform specific path (File.pathSeparator) from the given lists.%0a%0a%0a(:cellnr:)[[#pathseparator]]@@pathseparator@@%0a(:cell:)%0a(:cell:)Returns the current path separator as defined by @@File.pathSeparator@@%0a%0a%0a(:cellnr:)[[#range]]@@range@@%0a(:cell:); ('[' | '(') MASK ',' MASK (']' | ')') [ ; VERSION]%0a(:cell:)Create a version range from a version. The MASK is defined in [[#version|${version}]].%0a   %0a(:cellnr:)[[#replace]]@@replace@@%0a(:cell:); list ; regex ; replacement %0a(:cell:)Replace all elements of the list that match the regular expression regex with the replacement. The replacement can use the @@$[0-9]@@ back references defined in the regular expressions. The macro uses @@item.replaceAll(regex,replacement)@@ method to do the replacement.For example, to add a @@.jar@@ extension to all files listed, use the following: \\%0a@@List = ${replace;${impls};$;.jar}@@%0a%0a(:cellnr:)[[#sort]]@@sort@@%0a(:cell:); list%0a(:cell:)Sort the given list using string sorting collation. For example: \\%0a@@List= ${sort:acme.jar, harry.jar, runner.jar, alpha.jar, bugs.jar}@@%0a%0a(:cellnr:)[[#system]]@@system@@%0a(:cell:)system cmd%0a(:cell:)Execute a command via @@System.exec@@ and return the result as the macro's value.%0a%0a(:cellnr:)[[#toclassname]]@@toclassname@@%0a(:cell:); list%0a(:cell:)Replace a class path (with slashes and class at the end) to a class name (with dots).%0a%0a(:cellnr:)[[#toclasspath]]@@toclasspath@@%0a(:cell:); list  [ ; suffix ]%0a(:cell:)Replace a class name (with dots) to a classpath (with slashes and @@suffix@@ at the end). The default suffix is @@.class@@. The suffix may be empty%0a%0a(:cellnr:)[[#tstamp]]@@tstamp@@%0a(:cell:) ( date pattern )?%0a(:cell:)Answer a time stamp based on the pattern. The pattern is defined by the [[http://download.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html|SimpleDateFormat]]. The default pattern is @@yyyyMMddHHmm@@.%0a%0a%0a(:cellnr:)[[#unique]]@@unique@@%0a(:cell:); list ( ; list ) *%0a(:cell:)Split all the given lists on their commas, combine them in one list and remove any duplicates. The ordering is not preserved, see [[#sort|${sort}]] For example:%0a  %0a  ${unique; 1,2,3,1,2; 1,2,4 } ~ "2,4,3,1"%0a%0a(:cellnr:)[[#version]]@@version@@%0a(:cell:); mask ; version%0a(:cell:)This macro can modify a version by dropping parts from the end, incrementing parts, or decrementing parts. The mask is a string containing from 1 to 4 characters. The characters have the following meaning: \\%0a  = the actual version part \\%0a  + increment the actual version part \\%0a  - decrement the actual version part \\%0aFor example, ${version;=+;1.2.3.q} will become 1.3.%0a%0a%0a(:cellnr:)[[#warning]]@@warning@@%0a(:cell:)@@arg ( ';' arg ) *@@%0a(:cell:)Generate a warning for each @@arg@@.%0a%0a%0a(:tableend:)%0a%0a[[#classesx]]%0a!!classes macro%0aThe classes macro provides a query function in an analyzed bundle. While analyzing, the Analyzer stores each found class on the Bundle-Classpath with some key information. A simple query language is used to query this dictionary. For example, if you want to make a manifest header with all public classes in the bundle:%0a%0a  Public-Classes: ${classes;PUBLIC}%0a%0aThe query language is conjunctive, that is, all entries form an AND. For example, if you want to find all PUBLIC classes that are also not abstract you would do:%0a%0a  PublicConcrete-Classes: ${classes;CONCRETE}%0a%0aThe query can also parameters. This is a pattern that must match some aspect of the class. For example, it is possible to query for classes that extend a certain base class:%0a%0a  Test-Cases: ${classes;CONCRETE;EXTENDS;junit.framework.TestCase}%0a%0aAll pattern matching is based on fully qualified name and uses the globbing model.%0a%0aThe following table specifies what query options there are:%0a%0a(:table:)%0a(:cellnr:)'''Query'''%0a(:cell:)'''Parameter'''%0a(:cell:)'''Description'''%0a%0a(:cellnr:)IMPLEMENTS%0a(:cell:)PATTERN%0a(:cell:)The class must implement at least one interface that matches the given pattern. This takes inheritance into account as long as intermediates can be found the classpath%0a%0a(:cellnr:)EXTENDS%0a(:cell:)PATTERN%0a(:cell:)The class must implement at least one interface that matches the given pattern. This takes inheritance into account as long as intermediates can be found the classpath.%0a%0a(:cellnr:)IMPORTS%0a(:cell:)PATTERN%0a(:cell:)The class must use a type from another package that matches the given pattern%0a%0a(:cellnr:)NAMED%0a(:cell:)PATTERN%0a(:cell:)The class fqn must match the given pattern.%0a%0a(:cellnr:)ANY%0a(:cell:)%0a(:cell:)Matches any class%0a%0a(:cellnr:)VERSION%0a(:cell:)PATTERN%0a(:cell:)The class format of the given class must match the given version. The version is given as "%3cmajor>/%3cminor>", like "49/0". To select classes that are Java 6, do @@${classes;VERSION;49/*}@@%0a%0a(:cellnr:)CONCRETE%0a(:cell:)%0a(:cell:)Class must not be abstract%0a%0a(:cellnr:)ABSTRACT%0a(:cell:)%0a(:cell:)Class must be abstract%0a%0a(:cellnr:)PUBLIC%0a(:cell:)%0a(:cell:)Class must be public%0a%0a(:cellnr:)ANNOTATION%0a(:cell:)PATTERN%0a(:cell:)The class must have an annotation that matches the pattern. The set of annotations is all annotations in the class, also the annotations on fields and methods.%0a(:tableend:)%0a%0a!!!Caveat%0abnd will attempt to use the resources on the classpath if a super class or interface that is referenced from an analyzed class is not in the class space. However, bnd does not require that all dependencies are available on the classpath. In such a case it is not possible to do a complete analysis. For example, if A extends B and B extends C then it can only be determined that A extends C if B can be analyzed.%0a %0a
time=1298458392
title=05 Macros 
author:1298458392=
diff:1298458392:1294916184:=64c64%0a%3c (:cellnr:)[[#isdir]]@@isdir@@%0a---%0a> (:cellnr:)[[#isDir]]@@isDir@@%0a68c68%0a%3c (:cellnr:)[[#isfile]]@@isfile@@%0a---%0a> (:cellnr:)[[#isFile]]@@isFile@@%0a
host:1298458392=90.37.148.75
author:1294916184=
diff:1294916184:1288194599:=40,41c40,41%0a%3c (:cell:)Provides a query function to find classes to fulfill certain criteria. See the [[#classesx|classes]] macro%0a%3c %0a---%0a> (:cell:)Provides a query function to find classes to fullfil certain criteria. See the [[#classesx|classes]] macro%0a> %0a
host:1294916184=90.42.203.157
author:1288194599=
diff:1288194599:1288194009:=14a15,22%0a> There are a number of built in properties that are set by bnd:%0a> %0a> ||!Property name ||!Description ||%0a> ||@@project@@||Name of the project. This is the name of the bnd file without the .bnd extension. If this name is bnd.bnd, then the directory name is used. ||%0a> ||@@project.file@@||Absolute path of the main bnd file. ||%0a> ||@@project.name@@||Just the name part of the file path ||%0a> ||@@project.dir@@||The absolute path of the directory in which the bnd file resides. ||%0a> %0a
host:1288194599=90.41.125.248
author:1288194009=
diff:1288194009:1288193914:=1,2c1,2%0a%3c (:title 05 Macros :)%0a%3c %0a---%0a> (:title 04 Macros :)%0a> %0a5,6c5,6%0a%3c !05 Macros%0a%3c %0a---%0a> !04 Macros%0a> %0a
host:1288194009=90.41.125.248
author:1288193914=
diff:1288193914:1288193485:=218,221c218,221%0a%3c (:cellnr:)'''Query'''%0a%3c (:cell:)'''Parameter'''%0a%3c (:cell:)'''Description'''%0a%3c %0a---%0a> (:cellnr:)!Query         %0a> (:cell:)!Parameter   %0a> (:cell:)!Description%0a> %0a
host:1288193914=90.41.125.248
author:1288193485=
diff:1288193485:1288191488:=150c150%0a%3c (:cellnr:)[[#replace]]@@replace@@%0a---%0a> (:cellnr:)[#replace]]@@replace@@%0a
host:1288193485=90.41.125.248
author:1288191488=
diff:1288191488:1288191461:=48,49c48,49%0a%3c (:cell:)Provides a query function to find classes to fullfil certain criteria. See the [[#classesx|classes]] macro%0a%3c %0a---%0a> (:cell:)Provides a query function to find classes to fullfil certain criteria. See the [[#classes+|classes]] macro%0a> %0a199c199%0a%3c [[#classesx]]%0a---%0a> [[#classes+]]%0a
host:1288191488=90.41.125.248
author:1288191461=
diff:1288191461:1288177894:=48,49c48,49%0a%3c (:cell:)Provides a query function to find classes to fullfil certain criteria. See the [[#classes+|classes]] macro%0a%3c %0a---%0a> (:cell:)Provides a query function to find classes to fullfil certain criteria. See the [[#classes|classes]] macro%0a> %0a199c199%0a%3c [[#classes+]]%0a---%0a> [[#classes]]%0a
host:1288191461=90.41.125.248
author:1288177894=
diff:1288177894:1288177863:=39c39%0a%3c (:cell:)@@arg ( ';' arg )*@@%0a---%0a> (:cell:)@@arg ( ';' arg )*%0a
host:1288177894=90.41.125.248
author:1288177863=
diff:1288177863:1288177253:=42,45d41%0a%3c (:cellnr:)[[#cat]]@@cat@@%0a%3c (:cell:)@@arg@@%0a%3c (:cell:)If arg is a directory, return the contents of the directory. If it is a file, return the contents of the file.%0a%3c %0a132,140d127%0a%3c (:cellnr:)[[#osfile]]@@osfile@@%0a%3c (:cell:)@@base (';' PATH )*@@%0a%3c (:cell:)Return a comma separated list of absolute file paths in the current's OS' format. If the PATH is relative, it is calculated from the base directory.%0a%3c %0a%3c (:cellnr:)[[#path]]@@path@@%0a%3c (:cell:)LIST (';' LIST )*@@%0a%3c (:cell:)Return a platform specific path (File.pathSeparator) from the given lists.%0a%3c %0a%3c %0a
host:1288177863=90.41.125.248
author:1288177253=
diff:1288177253:1288177222:=129,132c129,132%0a%3c (:cell:)%0a%3c (:cell:)Returns the current path separator as defined by @@File.pathSeparator@@%0a%3c %0a%3c %0a---%0a> (:cellnr:)%0a> (:cellnr:)Returns the current path separator as defined by @@File.pathSeparator@@%0a> %0a> %0a
host:1288177253=90.41.125.248
author:1288177222=
diff:1288177222:1288175840:=33,41c33,37%0a%3c (:cell:)'''Function'''%0a%3c (:cell:)'''Arguments'''%0a%3c (:cell:)'''Description'''%0a%3c %0a%3c %0a%3c (:cellnr:)[[#basename]]@@basename@@%0a%3c (:cell:)@@arg ( ';' arg )*%0a%3c (:cell:)Return a comma separated list with all the file names (not directory) of the arguments. Non existent files are skipped.%0a%3c %0a---%0a> (:cell:)!Function%0a> (:cell:)!Arguments %0a> (:cell:)!Description%0a> %0a> %0a50,61d45%0a%3c (:cellnr:)[[#def]]@@def@@%0a%3c (:cell:)@@arg@@%0a%3c (:cell:)Provide the empty string if arg is not defined, otherwise it provides the value of the property @@arg@@.%0a%3c %0a%3c (:cellnr:)[[#dir]]@@dir@@%0a%3c (:cell:)@@arg ( ';' arg ) *%0a%3c (:cell:)Get the directory names of the arguments in a comma separated format. For example, ${dir;${project}} should provide the directory path (absolute) of the directory that contains the project%0a%3c %0a%3c (:cellnr:)[[#error]]@@error@@%0a%3c (:cell:)@@arg ( ';' arg ) *@@%0a%3c (:cell:)Generate an error for each @@arg@@.%0a%3c %0a64,75c48,50%0a%3c (:cell:)If the condition is not empty, the true part is returned, else the false part is returned. If not false part is supplied, the empty string is returned. The condition is trimmed before tested. For example:%0a%3c %0a%3c   Comment: ${if;${version};Ok;Version is NOT set!!!!}%0a%3c %0a%3c (:cellnr:)[[#isDir]]@@isDir@@%0a%3c (:cell:)@@arg@@%0a%3c (:cell:)Returns "true" when arg is an existing directory, otherwise "false".%0a%3c %0a%3c (:cellnr:)[[#isFile]]@@isFile@@%0a%3c (:cell:)@@arg@@%0a%3c (:cell:)Returns "true" when arg is an existing file, otherwise "false".%0a%3c %0a---%0a> (:cell:)If the condition is not empty, the true part is returned, else the false part is returned. If not false part is supplied, the empty string is returned. The condition is trimmed before tested. For example: \\%0a> @@Comment: ${if;${version};Ok;Version is NOT set!!!!}@@%0a> %0a106,117d80%0a%3c (:cellnr:)[[#literal]]@@literal@@%0a%3c (:cell:)@@arg@@%0a%3c (:cell:)Provide a literal macro for arg. For example, @@${literal;"project"}@@ results in @@"${project}"@@. Can be useful if information must be created for other systems that uses the macro syntax.%0a%3c %0a%3c (:cellnr:)[[#lsa]]@@lsa@@%0a%3c (:cell:)@@dir@@ ( ';' PATTERN ( ',' PATTERN )* )?%0a%3c (:cell:)Return the contents of the given directory filtered by the patterns. The result is a comma separated list of absolute file names.%0a%3c %0a%3c (:cellnr:)[[#lsr]]@@lsr@@%0a%3c (:cell:)@@dir@@ ( ';' PATTERN ( ',' PATTERN )* )?%0a%3c (:cell:)Return the contents of the given directory filtered by the patterns. The result is a comma separated list of relative file names.%0a%3c %0a128,132d90%0a%3c (:cellnr:)[[#pathseparator]]@@pathseparator@@%0a%3c (:cellnr:)%0a%3c (:cellnr:)Returns the current path separator as defined by @@File.pathSeparator@@%0a%3c %0a%3c %0a147,150d104%0a%3c (:cellnr:)[[#system]]@@system@@%0a%3c (:cell:)system cmd%0a%3c (:cell:)Execute a command via @@System.exec@@ and return the result as the macro's value.%0a%3c %0a159,163d112%0a%3c (:cellnr:)[[#tstamp]]@@tstamp@@%0a%3c (:cell:) ( date pattern )?%0a%3c (:cell:)Answer a time stamp based on the pattern. The pattern is defined by the [[http://download.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html|SimpleDateFormat]]. The default pattern is @@yyyyMMddHHmm@@.%0a%3c %0a%3c %0a178,183d126%0a%3c %0a%3c (:cellnr:)[[#warning]]@@warning@@%0a%3c (:cell:)@@arg ( ';' arg ) *@@%0a%3c (:cell:)Generate a warning for each @@arg@@.%0a%3c %0a%3c %0a
host:1288177222=90.41.125.248
author:1288175840=
diff:1288175840:1288175787:=117,118c117,118%0a%3c   ${unique; 1,2,3,1,2; 1,2,4 } ~ "2,4,3,1"%0a%3c %0a---%0a>   ${unique; 1,2,3,1,2; 1,2,4 } == "1,2,3,4"  # in any order%0a> %0a
host:1288175840=90.41.125.248
author:1288175787=
diff:1288175787:1288175449:=53c53%0a%3c (:cell:)The filter macro iterates over the given list and only includes elements that match the given regular expression (regex). The following example includes only the jar files from the list: \\%0a---%0a> {:cell:)The filter macro iterates over the given list and only includes elements that match the given regular expression (regex). The following example includes only the jar files from the list: \\%0a57c57%0a%3c (:cellnr:)[[#filterout]]@@filterout@@%0a---%0a> (:cellnr:)@@filterout@@%0a63c63%0a%3c (:cellnr:)[[#findname]]@@findname@@%0a---%0a> (:cellnr:)@@findname@@%0a67c67%0a%3c (:cellnr:)[[#findpath]]@@findpath@@%0a---%0a> (:cellnr:)@@findpath@@%0a71c71%0a%3c (:cellnr:)[[#fmodified]]@@fmodified@@%0a---%0a> (:cellnr:)@@fmodified@@%0a76c76%0a%3c (:cellnr:)[[#join]]@@join@@%0a---%0a> (:cellnr:)@@join@@%0a81c81%0a%3c (:cellnr:)[[#long2date]]@@long2date@@%0a---%0a> (:cellnr:)@@long2date@@%0a86c86%0a%3c (:cellnr:)[[#now]]@@now@@%0a---%0a> (:cellnr:)@@now@@%0a91c91%0a%3c (:cellnr:)[[#range]]@@range@@%0a---%0a> (:cellnr:)@@range@@%0a95c95%0a%3c (:cellnr:)[#replace]]@@replace@@%0a---%0a> (:cellnr:)@@replace@@%0a100c100%0a%3c (:cellnr:)[[#sort]]@@sort@@%0a---%0a> (:cellnr:)@@sort@@%0a105c105%0a%3c (:cellnr:)[[#toclassname]]@@toclassname@@%0a---%0a> (:cellnr:)@@toclassname@@%0a109c109%0a%3c (:cellnr:)[[#toclasspath]]@@toclasspath@@%0a---%0a> (:cellnr:)@@toclasspath@@%0a113,119c113%0a%3c (:cellnr:)[[#unique]]@@unique@@%0a%3c (:cell:); list ( ; list ) *%0a%3c (:cell:)Split all the given lists on their commas, combine them in one list and remove any duplicates. The ordering is not preserved, see [[#sort|${sort}]] For example:%0a%3c   %0a%3c   ${unique; 1,2,3,1,2; 1,2,4 } == "1,2,3,4"  # in any order%0a%3c %0a%3c (:cellnr:)[[#version]]@@version@@%0a---%0a> (:cellnr:)@@version@@%0a
host:1288175787=90.41.125.248
author:1288175449=
diff:1288175449:1288175402:=
host:1288175449=90.41.125.248
author:1288175402=
diff:1288175402:1288175295:=37,38c37%0a%3c %0a%3c (:cellnr:)[[#classes]]@@classes@@%0a---%0a> (:cellnr:)@@classes@@%0a42c41%0a%3c (:cellnr:)[[#env]]@@env@@%0a---%0a> (:cellnr:)@@env@@%0a46c45%0a%3c (:cellnr:)[[#if]]@@if@@%0a---%0a> (:cellnr:)@@if@@%0a51c50%0a%3c (:cellnr:)[[#filter]]@@filter@@%0a---%0a> (:cellnr:)@@filter@@%0a
host:1288175402=90.41.125.248
author:1288175295=
diff:1288175295:1288175240:=50c50%0a%3c (:cellnr:)@@filter@@%0a---%0a> {:cellnr:)@@filter@@%0a184,185c184%0a%3c (:tableend:)%0a%3c %0a---%0a> %0a
host:1288175295=90.41.125.248
author:1288175240=
diff:1288175240:1288174969:=17,22c17,22%0a%3c ||!Property name ||!Description ||%0a%3c ||@@project@@||Name of the project. This is the name of the bnd file without the .bnd extension. If this name is bnd.bnd, then the directory name is used. ||%0a%3c ||@@project.file@@||Absolute path of the main bnd file. ||%0a%3c ||@@project.name@@||Just the name part of the file path ||%0a%3c ||@@project.dir@@||The absolute path of the directory in which the bnd file resides. ||%0a%3c %0a---%0a> (:cell:)!Property name (:cell:)!Description (:cell:)%0a> (:cell:)@@project@@(:cell:)Name of the project. This is the name of the bnd file without the .bnd extension. If this name is bnd.bnd, then the directory name is used. (:cell:)%0a> (:cell:)@@project.file@@(:cell:)Absolute path of the main bnd file. (:cell:)%0a> (:cell:)@@project.name@@(:cell:)Just the name part of the file path (:cell:)%0a> (:cell:)@@project.dir@@(:cell:)The absolute path of the directory in which the bnd file resides. (:cell:)%0a> %0a112,114c112%0a%3c (:cellnr:)@@version@@%0a%3c (:cell:); mask ; version%0a%3c (:cell:)This macro can modify a version by dropping parts from the end, incrementing parts, or decrementing parts. The mask is a string containing from 1 to 4 characters. The characters have the following meaning: \\%0a---%0a> (:cellnr:)@@version@@(:cell:); mask ; version(:cell:)This macro can modify a version by dropping parts from the end, incrementing parts, or decrementing parts. The mask is a string containing from 1 to 4 characters. The characters have the following meaning: \\%0a140,184c138,149%0a%3c (:table:)%0a%3c (:cellnr:)!Query         %0a%3c (:cell:)!Parameter   %0a%3c (:cell:)!Description%0a%3c %0a%3c (:cellnr:)IMPLEMENTS%0a%3c (:cell:)PATTERN%0a%3c (:cell:)The class must implement at least one interface that matches the given pattern. This takes inheritance into account as long as intermediates can be found the classpath%0a%3c %0a%3c (:cellnr:)EXTENDS%0a%3c (:cell:)PATTERN%0a%3c (:cell:)The class must implement at least one interface that matches the given pattern. This takes inheritance into account as long as intermediates can be found the classpath.%0a%3c %0a%3c (:cellnr:)IMPORTS%0a%3c (:cell:)PATTERN%0a%3c (:cell:)The class must use a type from another package that matches the given pattern%0a%3c %0a%3c (:cellnr:)NAMED%0a%3c (:cell:)PATTERN%0a%3c (:cell:)The class fqn must match the given pattern.%0a%3c %0a%3c (:cellnr:)ANY%0a%3c (:cell:)%0a%3c (:cell:)Matches any class%0a%3c %0a%3c (:cellnr:)VERSION%0a%3c (:cell:)PATTERN%0a%3c (:cell:)The class format of the given class must match the given version. The version is given as "%3cmajor>/%3cminor>", like "49/0". To select classes that are Java 6, do @@${classes;VERSION;49/*}@@%0a%3c %0a%3c (:cellnr:)CONCRETE%0a%3c (:cell:)%0a%3c (:cell:)Class must not be abstract%0a%3c %0a%3c (:cellnr:)ABSTRACT%0a%3c (:cell:)%0a%3c (:cell:)Class must be abstract%0a%3c %0a%3c (:cellnr:)PUBLIC%0a%3c (:cell:)%0a%3c (:cell:)Class must be public%0a%3c %0a%3c (:cellnr:)ANNOTATION%0a%3c (:cell:)PATTERN%0a%3c (:cell:)The class must have an annotation that matches the pattern. The set of annotations is all annotations in the class, also the annotations on fields and methods.%0a%3c %0a---%0a> (:cell:)!Query         (:cell:)!Parameter   (:cell:)!Description(:cell:)%0a> (:cell:)IMPLEMENTS     (:cell:)PATTERN      (:cell:)The class must implement at least one interface that matches the given pattern. This takes inheritance into account as long as intermediates can be found the classpath(:cell:)%0a> (:cell:)EXTENDS        (:cell:)PATTERN      (:cell:)The class must implement at least one interface that matches the given pattern. This takes inheritance into account as long as intermediates can be found the classpath.(:cell:)%0a> (:cell:)IMPORTS        (:cell:)PATTERN      (:cell:)The class must use a type from another package that matches the given pattern(:cell:)%0a> (:cell:)NAMED          (:cell:)PATTERN      (:cell:)The class fqn must match the given pattern.(:cell:)%0a> (:cell:)ANY            (:cell:)             (:cell:)Matches any class(:cell:)%0a> (:cell:)VERSION        (:cell:)PATTERN      (:cell:)The class format of the given class must match the given version. The version is given as "%3cmajor>/%3cminor>", like "49/0". To select classes that are Java 6, do @@${classes;VERSION;49/*}@@(:cell:)%0a> (:cell:)CONCRETE       (:cell:)             (:cell:)Class must not be abstract(:cell:)%0a> (:cell:)ABSTRACT       (:cell:)             (:cell:)Class must be abstract(:cell:)%0a> (:cell:)PUBLIC         (:cell:)             (:cell:)Class must be public(:cell:)%0a> (:cell:)ANNOTATION     (:cell:)PATTERN      (:cell:)The class must have an annotation that matches the pattern. The set of annotations is all annotations in the class, also the annotations on fields and methods.(:cell:)%0a> %0a
host:1288175240=90.41.125.248
author:1288174969=
diff:1288174969:1287248583:=17,22c17,22%0a%3c (:cell:)!Property name (:cell:)!Description (:cell:)%0a%3c (:cell:)@@project@@(:cell:)Name of the project. This is the name of the bnd file without the .bnd extension. If this name is bnd.bnd, then the directory name is used. (:cell:)%0a%3c (:cell:)@@project.file@@(:cell:)Absolute path of the main bnd file. (:cell:)%0a%3c (:cell:)@@project.name@@(:cell:)Just the name part of the file path (:cell:)%0a%3c (:cell:)@@project.dir@@(:cell:)The absolute path of the directory in which the bnd file resides. (:cell:)%0a%3c %0a---%0a> ||!Property name ||!Description ||%0a> ||@@project@@||Name of the project. This is the name of the bnd file without the .bnd extension. If this name is bnd.bnd, then the directory name is used. ||%0a> ||@@project.file@@||Absolute path of the main bnd file. ||%0a> ||@@project.name@@||Just the name part of the file path ||%0a> ||@@project.dir@@||The absolute path of the directory in which the bnd file resides. ||%0a> %0a32,52c32,34%0a%3c (:table:)%0a%3c (:cell:)!Function%0a%3c (:cell:)!Arguments %0a%3c (:cell:)!Description%0a%3c %0a%3c (:cellnr:)@@classes@@%0a%3c (:cell:)QUERY%0a%3c (:cell:)Provides a query function to find classes to fullfil certain criteria. See the [[#classes|classes]] macro%0a%3c %0a%3c (:cellnr:)@@env@@%0a%3c (:cell:); name%0a%3c (:cell:)Provide the value of the given environment variable%0a%3c %0a%3c (:cellnr:)@@if@@%0a%3c (:cell:); condition ; true ( ; false ) ? %0a%3c (:cell:)If the condition is not empty, the true part is returned, else the false part is returned. If not false part is supplied, the empty string is returned. The condition is trimmed before tested. For example: \\%0a%3c @@Comment: ${if;${version};Ok;Version is NOT set!!!!}@@%0a%3c %0a%3c {:cellnr:)@@filter@@%0a%3c (:cell:)';' list ';' regex%0a%3c {:cell:)The filter macro iterates over the given list and only includes elements that match the given regular expression (regex). The following example includes only the jar files from the list: \\%0a---%0a> ||%0a> ||!Function ||!Arguments ||!Description ||%0a> ||@@filter@@||; list ; regex ||The filter macro iterates over the given list and only includes elements that match the given regular expression (regex). The following example includes only the jar files from the list: \\%0a54,58c36,37%0a%3c List= ${filter;${list};.*\\.jar}@@%0a%3c %0a%3c (:cellnr:)@@filterout@@%0a%3c (:cell:); list ; regex%0a%3c (:cell:)The filterout macro iterates over the given list and removes elements that match the given regular expression (regex). The following example strips the jar files from the list:  \\%0a---%0a> List= ${filter;${list};.*\\.jar}@@||%0a> ||@@filterout@@||; list ; regex ||The filterout macro iterates over the given list and removes elements that match the given regular expression (regex). The following example strips the jar files from the list:  \\%0a60,112c39,60%0a%3c List= ${filterout:${list};.*\\.jar}@@%0a%3c %0a%3c (:cellnr:)@@findname@@%0a%3c (:cell:); regex [ ; replacement ]  %0a%3c (:cell:)Find the paths to any resources that matches the regular expression, replace the name with the replacement of the regex. Notice that the regex is only executed on the name of the resource, that is, without the slashes.%0a%3c %0a%3c (:cellnr:)@@findpath@@%0a%3c (:cell:); regex [ ; replacement ]  %0a%3c (:cell:)Find the paths to any resources that matches the regular expression, replace the path with the replacement of the regex. Notice that the regex is executed on the path of the resource, that is, with the slashes.%0a%3c %0a%3c (:cellnr:)@@fmodified@@%0a%3c (:cell:); file-path-list %0a%3c (:cell:)Return the highest modification time of the given file path. The returned value is based on the epoch of Java, it is therefore a long.  \\%0a%3c @@Last-Modified: ${long2date;${fmodified;${files}})@@%0a%3c %0a%3c (:cellnr:)@@join@@%0a%3c (:cell:)( ; list ) *%0a%3c (:cell:)Joins a number of lists into one. It may seem that this can be easily accomplished by just placing two macro expansions after each other. The result of this will not be a list, unless a ',' (colon) is placed in between. However, when one of the lists is empty, the colon will be superfluous. The join handles these cases correctly. Any number of lists may be given as arguments. \\%0a%3c @@List= ${join;a,b,c;d,e,f}@@%0a%3c %0a%3c (:cellnr:)@@long2date@@%0a%3c (:cell:); long %0a%3c (:cell:)Parse the long and turn it into a date.  \\%0a%3c @@Last-Modified: ${long2date:${fmodified:${files}})@@%0a%3c %0a%3c (:cellnr:)@@now@@%0a%3c (:cell:)%0a%3c (:cell:)Returns the current Date as string.  \\%0a%3c @@Created-When: ${now}@@%0a%3c %0a%3c (:cellnr:)@@range@@%0a%3c (:cell:); ('[' | '(') MASK ',' MASK (']' | ')') [ ; VERSION]%0a%3c (:cell:)Create a version range from a version. The MASK is defined in [[#version|${version}]].%0a%3c    %0a%3c (:cellnr:)@@replace@@%0a%3c (:cell:); list ; regex ; replacement %0a%3c (:cell:)Replace all elements of the list that match the regular expression regex with the replacement. The replacement can use the @@$[0-9]@@ back references defined in the regular expressions. The macro uses @@item.replaceAll(regex,replacement)@@ method to do the replacement.For example, to add a @@.jar@@ extension to all files listed, use the following: \\%0a%3c @@List = ${replace;${impls};$;.jar}@@%0a%3c %0a%3c (:cellnr:)@@sort@@%0a%3c (:cell:); list%0a%3c (:cell:)Sort the given list using string sorting collation. For example: \\%0a%3c @@List= ${sort:acme.jar, harry.jar, runner.jar, alpha.jar, bugs.jar}@@%0a%3c %0a%3c (:cellnr:)@@toclassname@@%0a%3c (:cell:); list%0a%3c (:cell:)Replace a class path (with slashes and class at the end) to a class name (with dots).%0a%3c %0a%3c (:cellnr:)@@toclasspath@@%0a%3c (:cell:); list  [ ; suffix ]%0a%3c (:cell:)Replace a class name (with dots) to a classpath (with slashes and @@suffix@@ at the end). The default suffix is @@.class@@. The suffix may be empty%0a%3c %0a%3c (:cellnr:)@@version@@(:cell:); mask ; version(:cell:)This macro can modify a version by dropping parts from the end, incrementing parts, or decrementing parts. The mask is a string containing from 1 to 4 characters. The characters have the following meaning: \\%0a---%0a> List= ${filterout:${list};.*\\.jar}@@||%0a> ||@@env@@||; name ||Provide the value of the given environment variable||%0a> ||@@sort@@||; list ||Sort the given list using string sorting collation. For example: \\%0a> @@List= ${sort:acme.jar, harry.jar, runner.jar, alpha.jar, bugs.jar}@@ ||%0a> ||@@classes@@||QUERY||Provides a query function to find classes to fullfil certain criteria. See the [[#classes|classes]] macro||%0a> ||@@join@@||( ; list ) * ||Joins a number of lists into one. It may seem that this can be easily accomplished by just placing two macro expansions after each other. The result of this will not be a list, unless a ',' (colon) is placed in between. However, when one of the lists is empty, the colon will be superfluous. The join handles these cases correctly. Any number of lists may be given as arguments. \\%0a> @@List= ${join;a,b,c;d,e,f}@@ ||%0a> ||@@if@@||; condition ; true ( ; false ) ? ||If the condition is not empty, the true part is returned, else the false part is returned. If not false part is supplied, the empty string is returned. The condition is trimmed before tested. For example: \\%0a> @@Comment: ${if;${version};Ok;Version is NOT set!!!!}@@||%0a> ||@@now@@||||Returns the current Date as string.  \\%0a> @@Created-When: ${now}@@||%0a> ||@@fmodified@@||; file-path-list ||Return the highest modification time of the given file path. The returned value is based on the epoch of Java, it is therefore a long.  \\%0a> @@Last-Modified: ${long2date;${fmodified;${files}})@@||%0a> ||@@long2date@@||; long ||Parse the long and turn it into a date.  \\%0a> @@Last-Modified: ${long2date:${fmodified:${files}})@@||%0a> ||@@replace@@||; list ; regex ; replacement ||Replace all elements of the list that match the regular expression regex with the replacement. The replacement can use the @@$[0-9]@@ back references defined in the regular expressions. The macro uses @@item.replaceAll(regex,replacement)@@ method to do the replacement.For example, to add a @@.jar@@ extension to all files listed, use the following: \\%0a> @@List = ${replace;${impls};$;.jar}@@||%0a> ||@@toclassname@@||; list||Replace a class path (with slashes and class at the end) to a class name (with dots).||%0a> ||@@toclasspath@@||; list  [ ; suffix ]||Replace a class name (with dots) to a classpath (with slashes and @@suffix@@ at the end). The default suffix is @@.class@@. The suffix may be empty||%0a> ||@@findname@@||; regex [ ; replacement ]  ||Find the paths to any resources that matches the regular expression, replace the name with the replacement of the regex. Notice that the regex is only executed on the name of the resource, that is, without the slashes.||%0a> ||@@findpath@@||; regex [ ; replacement ]  ||Find the paths to any resources that matches the regular expression, replace the path with the replacement of the regex. Notice that the regex is executed on the path of the resource, that is, with the slashes.||%0a> ||@@version@@||; mask ; version||This macro can modify a version by dropping parts from the end, incrementing parts, or decrementing parts. The mask is a string containing from 1 to 4 characters. The characters have the following meaning: \\%0a116,119c64,65%0a%3c For example, ${version;=+;1.2.3.q} will become 1.3.%0a%3c %0a%3c (:tableend:)%0a%3c %0a---%0a> For example, ${version;=+;1.2.3.q} will become 1.3.||%0a> %0a138,149c84,95%0a%3c (:cell:)!Query         (:cell:)!Parameter   (:cell:)!Description(:cell:)%0a%3c (:cell:)IMPLEMENTS     (:cell:)PATTERN      (:cell:)The class must implement at least one interface that matches the given pattern. This takes inheritance into account as long as intermediates can be found the classpath(:cell:)%0a%3c (:cell:)EXTENDS        (:cell:)PATTERN      (:cell:)The class must implement at least one interface that matches the given pattern. This takes inheritance into account as long as intermediates can be found the classpath.(:cell:)%0a%3c (:cell:)IMPORTS        (:cell:)PATTERN      (:cell:)The class must use a type from another package that matches the given pattern(:cell:)%0a%3c (:cell:)NAMED          (:cell:)PATTERN      (:cell:)The class fqn must match the given pattern.(:cell:)%0a%3c (:cell:)ANY            (:cell:)             (:cell:)Matches any class(:cell:)%0a%3c (:cell:)VERSION        (:cell:)PATTERN      (:cell:)The class format of the given class must match the given version. The version is given as "%3cmajor>/%3cminor>", like "49/0". To select classes that are Java 6, do @@${classes;VERSION;49/*}@@(:cell:)%0a%3c (:cell:)CONCRETE       (:cell:)             (:cell:)Class must not be abstract(:cell:)%0a%3c (:cell:)ABSTRACT       (:cell:)             (:cell:)Class must be abstract(:cell:)%0a%3c (:cell:)PUBLIC         (:cell:)             (:cell:)Class must be public(:cell:)%0a%3c (:cell:)ANNOTATION     (:cell:)PATTERN      (:cell:)The class must have an annotation that matches the pattern. The set of annotations is all annotations in the class, also the annotations on fields and methods.(:cell:)%0a%3c %0a---%0a> ||!Query         ||!Parameter   ||!Description||%0a> ||IMPLEMENTS     ||PATTERN      ||The class must implement at least one interface that matches the given pattern. This takes inheritance into account as long as intermediates can be found the classpath||%0a> ||EXTENDS        ||PATTERN      ||The class must implement at least one interface that matches the given pattern. This takes inheritance into account as long as intermediates can be found the classpath.||%0a> ||IMPORTS        ||PATTERN      ||The class must use a type from another package that matches the given pattern||%0a> ||NAMED          ||PATTERN      ||The class fqn must match the given pattern.||%0a> ||ANY            ||             ||Matches any class||%0a> ||VERSION        ||PATTERN      ||The class format of the given class must match the given version. The version is given as "%3cmajor>/%3cminor>", like "49/0". To select classes that are Java 6, do @@${classes;VERSION;49/*}@@||%0a> ||CONCRETE       ||             ||Class must not be abstract||%0a> ||ABSTRACT       ||             ||Class must be abstract||%0a> ||PUBLIC         ||             ||Class must be public||%0a> ||ANNOTATION     ||PATTERN      ||The class must have an annotation that matches the pattern. The set of annotations is all annotations in the class, also the annotations on fields and methods.||%0a> %0a
host:1288174969=90.41.125.248
author:1287248583=
diff:1287248583:1287248547:=29c29,30%0a%3c %0a---%0a>          | '$«' function '»'%0a>          | '$‹' function '›'%0a
host:1287248583=90.41.247.141
author:1287248547=
diff:1287248547:1287246343:=2,6c2,3%0a%3c %0a%3c http://www.aqute.biz/uploads/Code/bnd.png%0a%3c %0a%3c !04 Macros%0a%3c %0a---%0a> !Macros%0a> %0a
host:1287248547=90.41.247.141
author:1287246343=
diff:1287246343:1287242539:=1,3c1,2%0a%3c (:title 04 Macros :)%0a%3c !Macros%0a%3c %0a---%0a> !! Macros%0a> %0a13a13%0a> ||%0a
host:1287246343=90.41.247.141
author:1287242539=
diff:1287242539:1287242539:=1,96d0%0a%3c !! Macros%0a%3c %0a%3c A simple macro processor is added to the header processing. Variables allow a single definition of a value, and the use of derivations. Each header is a macro that can be expanded. Notice that headers that do not start with an upper case character will not be copied to the manifest, so they can be used as working variables. Variables are expanded by enclosing the name of the variable in @@${%3cname>}@@ (curly braces) or @@$(%3cname>)@@ (parenthesis). Additionally, square brackets [], angled brackets %3c>, double guillemets «», and single guillemets ‹› are also allowed for brackets. If brackets are nested, that is $[replace;acaca;a(.*)a;[$1]] will return @@[cac]@@.%0a%3c %0a%3c For example:%0a%3c %0a%3c  version=1.23.87.200109111023542%0a%3c  Bundle-Version= ${version}%0a%3c  Bundle-Description= This bundle has version ${version}%0a%3c %0a%3c There are a number of built in properties that are set by bnd:%0a%3c %0a%3c ||%0a%3c ||!Property name ||!Description ||%0a%3c ||@@project@@||Name of the project. This is the name of the bnd file without the .bnd extension. If this name is bnd.bnd, then the directory name is used. ||%0a%3c ||@@project.file@@||Absolute path of the main bnd file. ||%0a%3c ||@@project.name@@||Just the name part of the file path ||%0a%3c ||@@project.dir@@||The absolute path of the directory in which the bnd file resides. ||%0a%3c %0a%3c There are also a number of macros that perform basic functions. All these functions have the following basic syntax:%0a%3c %0a%3c  macro ::= '${' function '}' %0a%3c          | '$[' function ']'%0a%3c          | '$(' function ')'%0a%3c          | '$%3c' function '>'%0a%3c          | '$«' function '»'%0a%3c          | '$‹' function '›'%0a%3c  function ::= name ( ':' argument ) *%0a%3c %0a%3c ||%0a%3c ||!Function ||!Arguments ||!Description ||%0a%3c ||@@filter@@||; list ; regex ||The filter macro iterates over the given list and only includes elements that match the given regular expression (regex). The following example includes only the jar files from the list: \\%0a%3c @@list= a,b,c,d,x.jar,z.jar \\%0a%3c List= ${filter;${list};.*\\.jar}@@||%0a%3c ||@@filterout@@||; list ; regex ||The filterout macro iterates over the given list and removes elements that match the given regular expression (regex). The following example strips the jar files from the list:  \\%0a%3c @@list= a,b,c,d,x.jar,z.jar \\%0a%3c List= ${filterout:${list};.*\\.jar}@@||%0a%3c ||@@env@@||; name ||Provide the value of the given environment variable||%0a%3c ||@@sort@@||; list ||Sort the given list using string sorting collation. For example: \\%0a%3c @@List= ${sort:acme.jar, harry.jar, runner.jar, alpha.jar, bugs.jar}@@ ||%0a%3c ||@@classes@@||QUERY||Provides a query function to find classes to fullfil certain criteria. See the [[#classes|classes]] macro||%0a%3c ||@@join@@||( ; list ) * ||Joins a number of lists into one. It may seem that this can be easily accomplished by just placing two macro expansions after each other. The result of this will not be a list, unless a ',' (colon) is placed in between. However, when one of the lists is empty, the colon will be superfluous. The join handles these cases correctly. Any number of lists may be given as arguments. \\%0a%3c @@List= ${join;a,b,c;d,e,f}@@ ||%0a%3c ||@@if@@||; condition ; true ( ; false ) ? ||If the condition is not empty, the true part is returned, else the false part is returned. If not false part is supplied, the empty string is returned. The condition is trimmed before tested. For example: \\%0a%3c @@Comment: ${if;${version};Ok;Version is NOT set!!!!}@@||%0a%3c ||@@now@@||||Returns the current Date as string.  \\%0a%3c @@Created-When: ${now}@@||%0a%3c ||@@fmodified@@||; file-path-list ||Return the highest modification time of the given file path. The returned value is based on the epoch of Java, it is therefore a long.  \\%0a%3c @@Last-Modified: ${long2date;${fmodified;${files}})@@||%0a%3c ||@@long2date@@||; long ||Parse the long and turn it into a date.  \\%0a%3c @@Last-Modified: ${long2date:${fmodified:${files}})@@||%0a%3c ||@@replace@@||; list ; regex ; replacement ||Replace all elements of the list that match the regular expression regex with the replacement. The replacement can use the @@$[0-9]@@ back references defined in the regular expressions. The macro uses @@item.replaceAll(regex,replacement)@@ method to do the replacement.For example, to add a @@.jar@@ extension to all files listed, use the following: \\%0a%3c @@List = ${replace;${impls};$;.jar}@@||%0a%3c ||@@toclassname@@||; list||Replace a class path (with slashes and class at the end) to a class name (with dots).||%0a%3c ||@@toclasspath@@||; list  [ ; suffix ]||Replace a class name (with dots) to a classpath (with slashes and @@suffix@@ at the end). The default suffix is @@.class@@. The suffix may be empty||%0a%3c ||@@findname@@||; regex [ ; replacement ]  ||Find the paths to any resources that matches the regular expression, replace the name with the replacement of the regex. Notice that the regex is only executed on the name of the resource, that is, without the slashes.||%0a%3c ||@@findpath@@||; regex [ ; replacement ]  ||Find the paths to any resources that matches the regular expression, replace the path with the replacement of the regex. Notice that the regex is executed on the path of the resource, that is, with the slashes.||%0a%3c ||@@version@@||; mask ; version||This macro can modify a version by dropping parts from the end, incrementing parts, or decrementing parts. The mask is a string containing from 1 to 4 characters. The characters have the following meaning: \\%0a%3c   = the actual version part \\%0a%3c   + increment the actual version part \\%0a%3c   - decrement the actual version part \\%0a%3c For example, ${version;=+;1.2.3.q} will become 1.3.||%0a%3c %0a%3c [[#classes]]%0a%3c !!classes macro%0a%3c The classes macro provides a query function in an analyzed bundle. While analyzing, the Analyzer stores each found class on the Bundle-Classpath with some key information. A simple query language is used to query this dictionary. For example, if you want to make a manifest header with all public classes in the bundle:%0a%3c %0a%3c   Public-Classes: ${classes;PUBLIC}%0a%3c %0a%3c The query language is conjunctive, that is, all entries form an AND. For example, if you want to find all PUBLIC classes that are also not abstract you would do:%0a%3c %0a%3c   PublicConcrete-Classes: ${classes;CONCRETE}%0a%3c %0a%3c The query can also parameters. This is a pattern that must match some aspect of the class. For example, it is possible to query for classes that extend a certain base class:%0a%3c %0a%3c   Test-Cases: ${classes;CONCRETE;EXTENDS;junit.framework.TestCase}%0a%3c %0a%3c All pattern matching is based on fully qualified name and uses the globbing model.%0a%3c %0a%3c The following table specifies what query options there are:%0a%3c %0a%3c ||!Query         ||!Parameter   ||!Description||%0a%3c ||IMPLEMENTS     ||PATTERN      ||The class must implement at least one interface that matches the given pattern. This takes inheritance into account as long as intermediates can be found the classpath||%0a%3c ||EXTENDS        ||PATTERN      ||The class must implement at least one interface that matches the given pattern. This takes inheritance into account as long as intermediates can be found the classpath.||%0a%3c ||IMPORTS        ||PATTERN      ||The class must use a type from another package that matches the given pattern||%0a%3c ||NAMED          ||PATTERN      ||The class fqn must match the given pattern.||%0a%3c ||ANY            ||             ||Matches any class||%0a%3c ||VERSION        ||PATTERN      ||The class format of the given class must match the given version. The version is given as "%3cmajor>/%3cminor>", like "49/0". To select classes that are Java 6, do @@${classes;VERSION;49/*}@@||%0a%3c ||CONCRETE       ||             ||Class must not be abstract||%0a%3c ||ABSTRACT       ||             ||Class must be abstract||%0a%3c ||PUBLIC         ||             ||Class must be public||%0a%3c ||ANNOTATION     ||PATTERN      ||The class must have an annotation that matches the pattern. The set of annotations is all annotations in the class, also the annotations on fields and methods.||%0a%3c %0a%3c !!!Caveat%0a%3c bnd will attempt to use the resources on the classpath if a super class or interface that is referenced from an analyzed class is not in the class space. However, bnd does not require that all dependencies are available on the classpath. In such a case it is not possible to do a complete analysis. For example, if A extends B and B extends C then it can only be determined that A extends C if B can be analyzed.%0a%3c  %0a
host:1287242539=90.41.247.141
